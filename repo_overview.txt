Oculizer/
    run_garage.py

    Content of run_garage.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('blue')
    light_controller = Oculizer('garage', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")

        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    run_laser.py

    Content of run_laser.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('laser')
    light_controller = Oculizer('laser', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    requirements.txt

    Content of requirements.txt:
    ----------------------------------------

    ----------------------------------------

    run_full.py

    Content of run_full.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('hell')
    light_controller = Oculizer('garage', scene_manager)
    spotifizer = Spotifizer()

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()
    spotifizer.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
            
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    test_imports.py

    Content of test_imports.py:
    ----------------------------------------
from oculizer import AudioListener, LightController, SceneManager, AudioLightController
from oculizer.config import audio_parameters
import time

print("AudioListener imported successfully")
print("LightController imported successfully")
print("SceneManager imported successfully")
print(f"Audio parameters: {audio_parameters}")

# Instantiate AudioListener to ensure it works
listener = AudioListener()
print("AudioListener instantiated successfully")

listener.start()  # Use start() instead of run()
time.sleep(2)
listener.stop()
listener.join()  # Wait for the thread to finish
print('AudioListener started, stopped, and joined successfully')

# Instantiate LightController to ensure it works
controller = LightController(listener, 'testing', SceneManager('scenes'))
print("LightController instantiated successfully")

controller.start()  # Use start() instead of run()
time.sleep(2)
controller.stop()
controller.join()  # Wait for the thread to finish
print('LightController started, stopped, and joined successfully')

# Instantiate SceneManager to ensure it works
manager = SceneManager('scenes')
print("SceneManager instantiated successfully")

print('SceneManager started, stopped, and joined successfully')

print("All imports and instantiations successful")
    ----------------------------------------

    spotify_credentials.txt

    Content of spotify_credentials.txt:
    ----------------------------------------
id d97b8894dcb848469851a24585519de8
secret 7fcdd929f0a545bdaebfdc30c1d74993
uri http://localhost:8000
username 1260351083
token BQBQeSU-AUrZhmSfOjwP1MHtniul_YZl4JjmL8yM2QbRWQDK7SmMGZjHi4WShgG6lhis9ijRKDiqV3DSenSZ0WL-3PcZhIIcDyVW1SBfdLnPkufRB9qIxyKVGOSd0tCXFncJh9Kq7dforq2F5uP4PBsNOjU85B3Tq1CaVdv01UuFCKsLue9PGEaIN_XIPCMITsBTC8j92vliY_at5fK4BvGQI2LFEZCS61OxmyXqhwSNIyr3n-no-0312CM9CHPkBEYhvAPp10GnPHJkspD-YRG0NWYG-fSDmkQ-SkvZOOJ-BWvI


    ----------------------------------------

    prepare_repo.py

    Content of prepare_repo.py:
    ----------------------------------------
import os

def is_relevant_file(filename):
    relevant_extensions = ('.py', '.json', '.md', '.txt')
    irrelevant_patterns = ('__pycache__', '.vscode', '.DS_Store', '.gitignore')
    return filename.endswith(relevant_extensions) and not any(pattern in filename for pattern in irrelevant_patterns)

def generate_repo_overview(root_dir):
    overview = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Remove hidden directories and files from the walk
        dirnames[:] = [d for d in dirnames if not d.startswith('.')]
        filenames = [f for f in filenames if not f.startswith('.') and is_relevant_file(f)]
        
        if not filenames:  # Skip empty directories
            continue
        
        level = dirpath.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        overview.append(f'{indent}{os.path.basename(dirpath)}/')
        sub_indent = ' ' * 4 * (level + 1)
        for f in filenames:
            overview.append(f'{sub_indent}{f}')
            file_path = os.path.join(dirpath, f)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                overview.append(f'\n{sub_indent}Content of {f}:')
                overview.append(f'{sub_indent}' + '-' * 40)
                overview.append(content)
                overview.append(f'{sub_indent}' + '-' * 40 + '\n')
    
    return '\n'.join(overview)

def main():
    root_dir = os.getcwd()  # Get the current working directory
    output_file = 'repo_overview.txt'
    
    repo_overview = generate_repo_overview(root_dir)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(repo_overview)
    
    print(f"Repository overview has been generated and saved to {output_file}")

if __name__ == "__main__":
    main()
    ----------------------------------------

    __init__.py

    Content of __init__.py:
    ----------------------------------------
from .audio.audio_listener import AudioListener
from .light.control import LightController
from .scenes.scene_manager import SceneManager



    ----------------------------------------

    run_dev.py

    Content of run_dev.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
from PyQt5.QtCore import QTimer
import pyqtgraph as pg

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager
from oculizer.config import audio_parameters

nmfft = audio_parameters['NMFFT']

class MFFTVisualizer(QMainWindow):
    def __init__(self, light_controller):
        super().__init__()
        self.setWindowTitle("MFFT Visualizer")
        self.setGeometry(100, 100, 800, 400)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.mfft_plot = pg.PlotWidget(title='Mel-scaled FFT')
        layout.addWidget(self.mfft_plot)

        self.mfft_bars = pg.BarGraphItem(x=range(nmfft), height=[0]*nmfft, width=0.8, brush='b')
        self.mfft_plot.addItem(self.mfft_bars)

        self.mfft_plot.setLabel('left', 'Magnitude')
        self.mfft_plot.setLabel('bottom', 'MFFT Coefficient')
        self.mfft_plot.showGrid(y=True)
        self.mfft_plot.setYRange(0, 20)
        self.mfft_plot.setXRange(-0.5, nmfft+0.5)

        self.light_controller = light_controller

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(10)  # Update every 10 ms

    def update_plot(self):
        try:
            mfft = self.light_controller.mfft_queue.get(block=False)
            if mfft is not None and len(mfft) == nmfft:
                self.mfft_bars.setOpts(height=mfft)
        except queue.Empty:
            pass

def curses_thread(stdscr, scene_manager, light_controller):
    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")

        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")
        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('blue')
    light_controller = Oculizer('garage', scene_manager)

    light_controller.start()

    app = QApplication(sys.argv)
    visualizer = MFFTVisualizer(light_controller)
    visualizer.show()

    curses_thread_obj = threading.Thread(target=curses_thread, args=(stdscr, scene_manager, light_controller))
    curses_thread_obj.start()

    app.exec_()

    light_controller.stop()
    light_controller.join()
    curses_thread_obj.join()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    README.md

    Content of README.md:
    ----------------------------------------
```    
          ___           ___           ___           ___                   ___           ___           ___     
         /\  \         /\  \         /\__\         /\__\      ___        /\  \         /\  \         /\  \    
        /::\  \       /::\  \       /:/  /        /:/  /     /\  \       \:\  \       /::\  \       /::\  \   
       /:/\:\  \     /:/\:\  \     /:/  /        /:/  /      \:\  \       \:\  \     /:/\:\  \     /:/\:\  \  
      /:/  \:\  \   /:/  \:\  \   /:/  /  ___   /:/  /       /::\__\       \:\  \   /::\~\:\  \   /::\~\:\  \ 
     /:/__/ \:\__\ /:/__/ \:\__\ /:/__/  /\__\ /:/__/     __/:/\/__/ _______\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ 
     \:\  \ /:/  / \:\  \  \/__/ \:\  \ /:/  / \:\  \    /\/:/  /    \::::::::/__/ \:\~\:\ \/__/ \/_|::\/:/  /
      \:\  /:/  /   \:\  \        \:\  /:/  /   \:\  \   \::/__/      \:\~~\~~      \:\ \:\__\      |:|::/  / 
       \:\/:/  /     \:\  \        \:\/:/  /     \:\  \   \:\__\       \:\  \        \:\ \/__/      |:|\/__/  
        \::/  /       \:\__\        \::/  /       \:\__\   \/__/        \:\__\        \:\__\        |:|  |    
         \/__/         \/__/         \/__/         \/__/                 \/__/         \/__/         \|__|    


```

Intelligent, real-time audio-reactive DMX lighting. 

In active development. 

    ----------------------------------------

    run_midi.py

    Content of run_midi.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import mido
from collections import OrderedDict

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager

def create_midi_scene_map(scenes):
    midi_scene_map = {}
    for scene_name, scene_data in scenes.items():
        if 'midi' in scene_data:
            midi_scene_map[scene_data['midi']] = scene_name
    return midi_scene_map

def sort_scenes_by_midi(scenes):
    scene_list = [(data.get('midi', float('inf')), name, data) for name, data in scenes.items()]
    sorted_scenes = sorted(scene_list, key=lambda x: x[0])
    return OrderedDict((name, data) for _, name, data in sorted_scenes)

def init_colors():
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_BLUE, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)
    curses.init_pair(6, curses.COLOR_CYAN, -1)
    curses.init_pair(7, curses.COLOR_WHITE, -1)
    curses.init_pair(8, curses.COLOR_BLACK, curses.COLOR_WHITE)  # For highlighting

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('party')  # Set an initial scene
    light_controller = Oculizer('garage', scene_manager)

    scene_manager.scenes = sort_scenes_by_midi(scene_manager.scenes)
    midi_scene_map = create_midi_scene_map(scene_manager.scenes)

    light_controller.start()

    try:
        inport = mido.open_input()
    except IOError:
        stdscr.addstr(0, 0, "No MIDI input port found. Please connect a MIDI device and restart.")
        stdscr.refresh()
        time.sleep(5)
        return

    stdscr.nodelay(1)
    init_colors()

    scroll_position = 0
    max_y, max_x = stdscr.getmaxyx()

    while True:
        stdscr.clear()
        max_y, max_x = stdscr.getmaxyx()

        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}", curses.color_pair(4))
        stdscr.addstr(1, 0, "Available scenes (sorted by MIDI):")

        visible_range = max_y - 5
        total_scenes = len(scene_manager.scenes)
        
        for i, (scene, data) in enumerate(list(scene_manager.scenes.items())[scroll_position:scroll_position+visible_range]):
            if i >= visible_range:
                break
            midi_note = data.get('midi', 'N/A')
            scene_str = f"{scene} | MIDI Note: {midi_note}"
            if len(scene_str) > max_x:
                scene_str = scene_str[:max_x-3] + "..."
            
            if scene == scene_manager.current_scene['name']:
                stdscr.attron(curses.color_pair(8) | curses.A_BOLD)
                stdscr.addstr(i+3, 0, scene_str)
                stdscr.attroff(curses.color_pair(8) | curses.A_BOLD)
            else:
                stdscr.addstr(i+3, 0, scene_str, curses.color_pair(2))

        if total_scenes > visible_range:
            stdscr.addstr(max_y-2, 0, f"Scroll: {scroll_position+1}-{min(scroll_position+visible_range, total_scenes)}/{total_scenes}")
        stdscr.addstr(max_y-1, 0, "Press 'q' to quit. 'r' to reload. Up/Down to scroll.", curses.color_pair(5))
        
        stdscr.refresh()

        for msg in inport.iter_pending():
            if msg.type == 'note_on':
                if msg.note in midi_scene_map:
                    try:
                        light_controller.change_scene(midi_scene_map[msg.note])
                    except Exception as e:
                        stdscr.addstr(max_y-1, 0, f"Error changing scene: {str(e)}")

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key == ord('r'):
            scene_manager.reload_scenes()
            scene_manager.scenes = sort_scenes_by_midi(scene_manager.scenes)
            midi_scene_map = create_midi_scene_map(scene_manager.scenes)
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(max_y-1, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)
        elif key == curses.KEY_UP and scroll_position > 0:
            scroll_position -= 1
        elif key == curses.KEY_DOWN and scroll_position < total_scenes - visible_range:
            scroll_position += 1
        elif key != -1:
            key_char = chr(key) if 0 <= key <= 255 else None
            if key_char in [scene['key_command'] for scene in scene_manager.scenes.values() if 'key_command' in scene]:
                for scene, data in scene_manager.scenes.items():
                    if data.get('key_command') == key_char:
                        light_controller.change_scene(scene)
                        break

        time.sleep(0.01)

    curses.endwin()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    setup.py

    Content of setup.py:
    ----------------------------------------
from setuptools import setup, find_packages

setup(
    name="oculizer",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        # List your dependencies here
        'numpy',
        'scipy',
        'sounddevice',
        'librosa',
        'pydub',
        'scipy', 
        'sounddevice',
        'soundfile',
        'sklearn',
        'PyDMXControl'
    ],
)
    ----------------------------------------

    run_printer.py

    Content of run_printer.py:
    ----------------------------------------
import mido
import time

def print_midi_notes():
    print("MIDI Note Printer")
    print("=================")
    print("Press keys on your MIDI keyboard to see their note numbers.")
    print("Press Ctrl+C to exit.")
    print()

    try:
        with mido.open_input() as inport:
            print(f"Listening on MIDI input: {inport.name}")
            print()
            
            while True:
                for msg in inport.iter_pending():
                    if msg.type == 'note_on':
                        note_name = msg.note
                        print(f" Number: {msg.note:3d}") # Name: {note_name:>3}, Velocity: {msg.velocity:3d}")
                    # elif msg.type == 'note_off':
                    #     note_name = msg.note
                    #     print(f"Note Off - Number: {msg.note:3d}, Name: {note_name:>3}, Velocity: {msg.velocity:3d}")
                time.sleep(0.01)  # Short sleep to prevent CPU hogging
                
    except KeyboardInterrupt:
        print("\nExiting...")

if __name__ == "__main__":
    print_midi_notes()
    ----------------------------------------

    run_tester.py

    Content of run_tester.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('hell')
    light_controller = Oculizer('testing', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    scenes/
        build4.json

        Content of build4.json:
        ----------------------------------------
{
    "name": "build4",
    "description": "Gradually intensifying scene for track buildups",
    "key_command": "b",
    "midi": 50,
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": "sine",
            "frequency": 1,
            "min_brightness": 0,
            "max_brightness": 90
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "time",
            "function": "sine",
            "frequency": 1,
            "min_brightness": 0,
            "max_brightness": 100
        }
    ]
}
        ----------------------------------------

        drop2.json

        Content of drop2.json:
        ----------------------------------------
{
    "name": "drop2",
    "description": "Intense lighting for the drop",
    "key_command": "d",
    "midi": 53,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 16],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "red",
            "strobe": 200
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [16, 32],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "orange",
            "strobe": 200
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [32, 48],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "yellow",
            "strobe": 200
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [48, 64],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "green",
            "strobe": 200
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [64, 80],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "blue",
            "strobe": 200
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [80, 96],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "purple",
            "strobe": 200
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [96, 112],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "pink",
            "strobe": 200
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [112, 128],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "white",
            "strobe": 200
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 255
        }
    ]
}
        ----------------------------------------

        ambient2.json

        Content of ambient2.json:
        ----------------------------------------
{
    "name": "ambient2",
    "description": "Subtle, flowing colors for calmer moments",
    "key_command": "a",
    "midi": 41,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.1,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.08,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.12,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.09,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.11,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.07,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.13,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.06,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "red"
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": 0,
            "frequency": 0.175,
            "min_brightness": 0,
            "max_brightness": 75
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "time",
            "function": 0,
            "frequency": 0.25,
            "min_brightness": 0,
            "max_brightness": 100
        }
    ]
}
        ----------------------------------------

        flicker.json

        Content of flicker.json:
        ----------------------------------------
{
    "name": "flicker",
    "description": "flicker vintage",
    "key_command": "v",
    "midi": 84,
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random",
            "min_brightness": 40,
            "max_brightness": 70
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random",
            "min_brightness": 50,
            "max_brightness": 100
        }
    ]
} 


        ----------------------------------------

        brainblaster.json

        Content of brainblaster.json:
        ----------------------------------------
{
    "name": "brainblaster",
    "description": "Rainbow strobes. All else off.",
    "key_command": "3",
    "midi": 67,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "random",
            "strobe": "random"
        }
    ]
}

        ----------------------------------------

        ambient3.json

        Content of ambient3.json:
        ----------------------------------------
{
    "name": "ambient3",
    "description": "Subtle, flowing colors for calmer moments",
    "key_command": "a",
    "midi": 40,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.1,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "green"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.08,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "orange"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.12,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "green"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.09,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "orange"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.11,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "green"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.07,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "orange"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.13,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "green"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.06,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "orange"
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random",
            "min_brightness": 40,
            "max_brightness": 70
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random",
            "min_brightness": 50,
            "max_brightness": 100
        }
    ]
}
        ----------------------------------------

        drop3.json

        Content of drop3.json:
        ----------------------------------------
{
    "name": "drop3",
    "description": "Intense lighting for the drop",
    "key_command": "d",
    "midi": 55,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 16],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "red",
            "strobe": 200
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [16, 32],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "orange",
            "strobe": 200
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [32, 48],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "yellow",
            "strobe": 200
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [48, 64],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "green",
            "strobe": 200
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [64, 80],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "blue",
            "strobe": 200
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [80, 96],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "purple",
            "strobe": 200
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [96, 112],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "pink",
            "strobe": 200
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [112, 128],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "white",
            "strobe": 200
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 255
        }
    ]
}
        ----------------------------------------

        bloop.json

        Content of bloop.json:
        ----------------------------------------
{
    "name": "bloop",
    "description": "Stochastic blue strobe on all RGBs. All else off.",
    "key_command": "f",
    "midi": 62,
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "max_brightness": 255,
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "blue",
            "strobe": "random"
        }
    ]
}
        ----------------------------------------

        ambient4.json

        Content of ambient4.json:
        ----------------------------------------
{
    "name": "ambient4",
    "description": "Subtle, flowing colors for calmer moments",
    "key_command": "a",
    "midi": 43,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.1,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.08,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.12,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.09,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.11,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.07,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.13,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.06,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "white"
        }
    ]
}
        ----------------------------------------

        bluevelvet.json

        Content of bluevelvet.json:
        ----------------------------------------
{
    "name": "bluevelvet",
    "description": "Vintage + blue",
    "key_command": "v",
    "midi": 71,
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [0, 50],      
            "brightness_range": [50, 200],
            "power_range": [0, 5]
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [50, 128],
            "brightness_range": [0, 255],
            "power_range": [0, 0.3]
        },
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "power_range": [0, 10],
            "brightness_range": [10, 60],
            "color": "blue",
            "strobe": 0
        }
    ]
}

        ----------------------------------------

        off.json

        Content of off.json:
        ----------------------------------------
{
    "name": "off",
    "description": "All lights off",
    "key_command": "o",
    "midi": 36,
    "lights": 
    [
    
    ]
}
        ----------------------------------------

        build2.json

        Content of build2.json:
        ----------------------------------------
{
    "name": "build2",
    "description": "Gradually intensifying scene for track buildups",
    "key_command": "b",
    "midi": 47,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.0,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.1,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.2,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.3,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.4,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.6,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "square",
            "frequency": 1.7,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "strobe": 255
        }
    ]
}
        ----------------------------------------

        discovibe.json

        Content of discovibe.json:
        ----------------------------------------
{
    "name": "discovibe",
    "description": "Disco scene + purple and pink",
    "key_command": "4",
    "midi": 76,
    "lights": [
        {
            "name": "discoball",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 100
        },
        {
            "name": "ropes", 
            "type": "dimmer",
            "modulator": "mfft", 
            "mfft_range": [0, 128],
            "brightness_range": [20, 60],
            "power_range": [0, 5]
        }, 
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft", 
            "brightness_range": [0, 60],
            "color": "purple",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft", 
            "brightness_range": [0, 60],
            "color": "blue",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 60],
            "color": "blue",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [20, 60],
            "color": "blue",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 60],
            "color": "blue",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 60],
            "color": "blue",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb8", 
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 60],
            "color": "pink",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 60],
            "color": "purple",
            "strobe": 0,
            "mfft_range": [0, 128],
            "power_range": [0, 7]
        }
    ]
}
        ----------------------------------------

        drop4.json

        Content of drop4.json:
        ----------------------------------------
{
    "name": "drop4",
    "description": "Intense lighting for the drop",
    "key_command": "d",
    "midi": 57,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 16],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "red",
            "strobe": 200
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [16, 32],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "orange",
            "strobe": 200
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [32, 48],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "yellow",
            "strobe": 200
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [48, 64],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "green",
            "strobe": 200
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [64, 80],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "blue",
            "strobe": 200
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [80, 96],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "purple",
            "strobe": 200
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [96, 112],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "pink",
            "strobe": 200
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [112, 128],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "white",
            "strobe": 200
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 255
        }
    ]
}
        ----------------------------------------

        hell.json

        Content of hell.json:
        ----------------------------------------
{
    "name": "hell",
    "description": "Stochastic red strobe on rgbs. All else off.",
    "key_command": "8",
    "midi": 59,
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "max_brightness": 50,
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "red",
            "strobe": "random"
        }
    ]
}
        ----------------------------------------

        discolaser.json

        Content of discolaser.json:
        ----------------------------------------
{
    "name": "discolaser",
    "description": "Disco scene w/ lasers",
    "key_command": "4",
    "midi": 74,
    "lights": [
        {
            "name": "discoball",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 100
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 255
        }

    ]
}
        ----------------------------------------

        build3.json

        Content of build3.json:
        ----------------------------------------
{
    "name": "build3",
    "description": "Gradually intensifying scene for track buildups",
    "key_command": "b",
    "midi": 48,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "white",
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        disco.json

        Content of disco.json:
        ----------------------------------------
{
    "name": "disco",
    "description": "Disco scene. Disco ball and RGB wavies.",
    "key_command": "4",
    "midi": 72,
    "lights": [
        {
            "name": "discoball",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 100
        }
    ]
}
        ----------------------------------------

        blue.json

        Content of blue.json:
        ----------------------------------------
{
    "name": "blue",
    "description": "blue",
    "midi": 79,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "color": "blue",
            "brightness": 255,
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        vintage.json

        Content of vintage.json:
        ----------------------------------------
{
    "name": "vintage",
    "description": "Warm and cozy for acoustic songs.",
    "key_command": "v",
    "midi": 69,
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [0, 50],      
            "brightness_range": [50, 200],
            "power_range": [0, 5]
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [50, 128],
            "brightness_range": [60, 255],
            "power_range": [0, 0.3]
        }
    ]
} 


        ----------------------------------------

        slime.json

        Content of slime.json:
        ----------------------------------------
{
    "name": "slime",
    "description": "Stochastic green strobe on all RGBs. All else off.",
    "key_command": "k",
    "midi": 60,
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "max_brightness": 255,
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": "random"
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 0
        },
        {
            "name": "discoball",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 0
        }
    ]
}
        ----------------------------------------

        electric.json

        Content of electric.json:
        ----------------------------------------
{
    "name": "electric",
    "description": "Stochastic white strobe on rgbs. All else off.",
    "key_command": "5",
    "midi": 65,
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "max_brightness": 50,
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "white",
            "strobe": "random"
        },
        {
            "name": "strobe",
            "type": "strobe",
            "modulator": "bool",
            "brightness": "random",
            "speed": "random"
        }
    ]
}
        ----------------------------------------

        build1.json

        Content of build1.json:
        ----------------------------------------
{
    "name": "build1",
    "description": "Gradually intensifying scene for track buildups",
    "key_command": "b",
    "midi": 45,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "mfft_range": [0, 16],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [16, 32],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [32, 48],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [48, 64],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [64, 80],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [80, 96],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [96, 112],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [16, 32],
            "power_range": [0, 2],
            "brightness_range": [0, 255],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.75,
            "min_brightness": 0,
            "max_brightness": 90
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.25,
            "min_brightness": 0,
            "max_brightness": 100
        }
    ]
}
        ----------------------------------------

        fullstrobe.json

        Content of fullstrobe.json:
        ----------------------------------------
{
    "name": "fullstrobe",
    "description": "Full white strobe all (RGB+Strobe)",
    "key_command": "6",
    "midi": 81,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "strobe",
            "type": "strobe",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 255,
            "speed": 245
        }, 
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "white",
            "strobe": 200
        }
    ]
}

        ----------------------------------------

        fairies.json

        Content of fairies.json:
        ----------------------------------------
{
    "name": "fairies",
    "description": "Stochastic purple strobe on all RGBs. All else off.",
    "key_command": "f",
    "midi": 64,
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "max_brightness": 255,
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "purple",
            "strobe": "random"
        }
    ]
}
        ----------------------------------------

        ambient1.json

        Content of ambient1.json:
        ----------------------------------------
{
    "name": "ambient1",
    "description": "Subtle, flowing colors for calmer moments",
    "key_command": "a",
    "midi": 38,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.1,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "blue"
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.08,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "purple"
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.12,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "blue"
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.09,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "purple"
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.11,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "blue"
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.07,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "purple"
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.13,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "blue"
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.06,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "purple"
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.05,
            "min_brightness": 0,
            "max_brightness": 75
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.04,
            "min_brightness": 0,
            "max_brightness": 100
        }
    ]
}
        ----------------------------------------

        party.json

        Content of party.json:
        ----------------------------------------
{
    "name": "party",
    "description": "Default basic party scene :).",
    "key_command": "1",
    "midi": 82,
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 20],
            "mfft_range": [0, 20],
            "power_range": [0,50],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb2", 
            "type": "rgb",
            "modulator": "mfft", 
            "brightness_range": [1, 20],
            "mfft_range": [50, 75],
            "power_range": [0,1],
            "color": "pink",
            "strobe": 0
        }, 
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "brightness": 100,
            "color": "pink",
            "strobe":255,
            "mfft_range": [110, 127],
            "power_range": [0.001,0.1],
            "brightness_range": [1, 25]
        }, 
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [50,90],
            "color": "blue",
            "power_range": [0.5, 1.0],
            "brightness_range": [0, 20],
            "strobe": 255
        }, 
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 20],
            "mfft_range": [1, 3],
            "power_range": [0,1],
            "color": "purple"
        }, 
        {
            "name": "ropes", 
            "type": "dimmer",
            "modulator": "time", 
            "function": 0,
            "frequency": 0.2,
            "min_brightness": 35,
            "max_brightness": 65
        }, 
        {
            "name": "orb", 
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [0, 10],
            "power_range": [0, 0.5],
            "brightness_range": [0, 80]
        },
        {
            "name": "discoball", 
            "type": "dimmer",
            "modulator": "time", 
            "function": 2, 
            "frequency": 0.2,
            "min_brightness": 0,
            "max_brightness": 0
        }, 
        {
            "name": "strobe", 
            "type": "strobe",
            "modulator": "mfft",
            "threshold": 0.05,
            "brightness": 255,
            "mfft_range": [115, 127],
            "power_range": [0.08, 1.0],
            "speed": 1
        },
        {
            "name": "rgb6", 
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 50],
            "mfft_range": [1, 3],
            "power_range": [0,5],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb7", 
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 20],
            "mfft_range": [15, 30],
            "power_range": [5,100],
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb8", 
            "type": "rgb",
            "modulator": "mfft", 
            "brightness_range": [1, 75],
            "mfft_range": [50, 75],
            "power_range": [0,3],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random"
        }
    ]
}
        ----------------------------------------

        whispers.json

        Content of whispers.json:
        ----------------------------------------
{
    "name": "whispers",
    "description": "A very dim, spooky scene with subtle, unsettling movements",
    "key_command": "w",
    "midi": 83,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.05,
            "min_brightness": 0,
            "max_brightness": 20,
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.07,
            "min_brightness": 0,
            "max_brightness": 15,
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "triangle",
            "frequency": 0.03,
            "min_brightness": 0,
            "max_brightness": 25,
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0, 0.5],
            "brightness_range": [0, 30],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_backward",
            "frequency": 0.02,
            "min_brightness": 0,
            "max_brightness": 20,
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [20, 40],
            "power_range": [0, 0.5],
            "brightness_range": [0, 25],
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.04,
            "min_brightness": 0,
            "max_brightness": 15,
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "triangle",
            "frequency": 0.06,
            "min_brightness": 0,
            "max_brightness": 20,
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": 1,
            "frequency": 0.01,
            "min_brightness": 0,
            "max_brightness": 30
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [0, 30],
            "power_range": [0, 0.3],
            "brightness_range": [0, 70]
        },
        {
            "name": "strobe",
            "type": "strobe",
            "modulator": "bool",
            "brightness": 0,
            "speed": 0
        }
    ]
}
        ----------------------------------------

        goosebumps.json

        Content of goosebumps.json:
        ----------------------------------------
{
    "name": "goosebumps",
    "description": "Eerie lighting inspired by a creepy TV show intro",
    "key_command": "i",
    "midi": 77,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 50,
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 175,
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 30],
            "power_range": [0, 1],
            "brightness_range": [0, 100],
            "color": "orange",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [30, 60],
            "power_range": [0, 1],
            "brightness_range": [0, 150],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "bool",
            "brightness": "random",
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_backward",
            "frequency": 0.25,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_backward",
            "frequency": 0.25,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "green",
            "strobe": 0
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": 2,
            "frequency": 0.5,
            "min_brightness": 0,
            "max_brightness": 0
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random",
            "min_brightness": 50,
            "max_brightness": 100
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random",
            "min_brightness": 50,
            "max_brightness": 70
        },
        {
            "name": "strobe",
            "type": "strobe",
            "modulator": "bool",
            "brightness": 150,
            "speed": 100
        }
    ]
}
        ----------------------------------------

        drop1.json

        Content of drop1.json:
        ----------------------------------------
{
    "name": "drop1",
    "description": "Intense lighting for the drop",
    "key_command": "d",
    "midi": 52,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 16],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "red",
            "strobe": 200
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [16, 32],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "orange",
            "strobe": 200
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [32, 48],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "yellow",
            "strobe": 200
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [48, 64],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "green",
            "strobe": 200
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [64, 80],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "blue",
            "strobe": 200
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [80, 96],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "purple",
            "strobe": 200
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [96, 112],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "pink",
            "strobe": 200
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [112, 128],
            "power_range": [0, 2],
            "brightness_range": [100, 255],
            "color": "white",
            "strobe": 200
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 255
        }
    ]
}
        ----------------------------------------

    config/
        audio_parameters.json

        Content of audio_parameters.json:
        ----------------------------------------
{
    "SAMPLERATE": 16000,
    "BLOCKSIZE": 512,
    "NMFFT": 128
}
        ----------------------------------------

    scenes_staging/
        laser.json

        Content of laser.json:
        ----------------------------------------
{
    "name": "laser",
    "description": "Laser only",
    "key_command": "`",
    "midi": 96,
    "lights": [
        {
            "name": "laser", 
            "type": "laser",
            "modulator": "mfft",
            "power_range": [0.3, 0.5]
        }
    ]
}
        ----------------------------------------

        groove.json

        Content of groove.json:
        ----------------------------------------
{
    "name": "groove",
    "description": "Good for Gorillaz, Earth Wind Fire, Super Freak",
    "key_command": "g",
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 255],
            "mfft_range": [1, 3],
            "power_range": [2, 15],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.2,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "blue",
            "strobe": 0
        }
    ]

}
        ----------------------------------------

        wavies.json

        Content of wavies.json:
        ----------------------------------------
{
    "name": "wavies",
    "description": "Sine waves for testing.",
    "key_command": "-",
    "midi": 71,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "frequency": 0.75,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "green",
            "frequency": 0.5,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "blue",
            "frequency": 1.0,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "yellow",
            "frequency": 0.4,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "orange",
            "frequency": 0.3,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "purple",
            "frequency": 0.5,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "green",
            "frequency": 0.1,
            "function": "sine",
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        white.json

        Content of white.json:
        ----------------------------------------
{
    "name": "white",
    "description": "White",
    "key_command": "0",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.5,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 2.7,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.8,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 0.9,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 2.2,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.3,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 2.7,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.8,
            "function": "sawtooth_forward",
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        tension.json

        Content of tension.json:
        ----------------------------------------
{
    "name": "tension",
    "description": "For building towards a drop.",
    "key_command": "9",
    "lights": 
    [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "fft",
            "brightness": 100,
            "color": "blue",
            "strobe": 0,
            "frequency_range": [0, 1000],
            "power_range": [0, 1],
            "brightness_range": [0, 255]

        }
    ]

}
        ----------------------------------------

    oculizer.egg-info/
        SOURCES.txt

        Content of SOURCES.txt:
        ----------------------------------------
README.md
setup.py
custom_profiles/ADJ_strobe.py
custom_profiles/RGB.py
custom_profiles/__init__.py
oculizer/__init__.py
oculizer/config.py
oculizer/interface.py
oculizer/utils.py
oculizer/visualizer.py
oculizer.egg-info/PKG-INFO
oculizer.egg-info/SOURCES.txt
oculizer.egg-info/dependency_links.txt
oculizer.egg-info/requires.txt
oculizer.egg-info/top_level.txt
oculizer/audio/__init__.py
oculizer/audio/audio_listener.py
oculizer/light/__init__.py
oculizer/light/control.py
oculizer/light/mapping.py
oculizer/scenes/__init__.py
oculizer/scenes/scene_manager.py
oculizer/scenes/scene_prediction.py
oculizer/spotify/__init__.py
oculizer/spotify/spotifizer.py
        ----------------------------------------

        requires.txt

        Content of requires.txt:
        ----------------------------------------
numpy
scipy
sounddevice
librosa
pyaudio
pydub
scipy
sounddevice
soundfile
sklearn
PyDMXControl

        ----------------------------------------

        top_level.txt

        Content of top_level.txt:
        ----------------------------------------
custom_profiles
oculizer

        ----------------------------------------

        dependency_links.txt

        Content of dependency_links.txt:
        ----------------------------------------


        ----------------------------------------

    scripts/
        extract_features.py

        Content of extract_features.py:
        ----------------------------------------

# %%
import librosa
import numpy as np
from pathlib import Path
import allin1
from allin1.helpers import save_results
from tqdm import tqdm
import json

# %%
songdir = Path('../../music/halloween2k24')
savedir = Path('../../music/halloween2k24_features')
songs = [str(i) for i in songdir.glob('*.mp3')]
# %%

def main():
	for s, song in enumerate(songs):
		# check if song has been processed
		if not Path(f'../../music/halloween2k24_features/{Path(song).stem}.json').exists():
			print(f"Processing song {s}: {song}")
			result = allin1.analyze(song, demix_dir='demix', keep_byproducts=True, include_activations=True, include_embeddings=True)
			save_results(result, savedir)
		else:
			print(f"{Path(song).stem} already processed. Skipping")
		
if __name__ == '__main__':
	main()

        ----------------------------------------

    profiles/
        testing.json

        Content of testing.json:
        ----------------------------------------
{
    "name": "testing",
    "description": "Testing profile. This works as the template lighting profile for running tests with two rgbs.",
    "lights": [
        {"name": "rgb1", "type": "rgb", "n_channels": 6},
        {"name": "rgb2", "type": "rgb", "n_channels": 6}
    ]
}
        ----------------------------------------

        laser.json

        Content of laser.json:
        ----------------------------------------
{
    "name": "laser",
    "description": "Laser testing profile. This works as the template lighting profile for running tests with the laser.",
    "lights": [
        {"name": "laser", "type": "laser", "n_channels": 10}
    ]
}
        ----------------------------------------

        garage.json

        Content of garage.json:
        ----------------------------------------
{
    "name": "garage",
    "description": "Garage",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "orb",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "discoball",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "strobe",
            "type": "strobe",
            "n_channels": 2
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "n_channels": 6
        }
    ]
}
        ----------------------------------------

        default.json

        Content of default.json:
        ----------------------------------------
{
    "name": "default",
    "description": "Default profile. This works as the template lighting profile for running tests.",
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "disco_ball",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "lamp",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "strobe",
            "type": "strobe",
            "n_channels": 2
        },
        {
            "name": "rgb",
            "type": "rgb",
            "n_channels": 7
        }
    ]
}
        ----------------------------------------

    oculizer/
        config.py

        Content of config.py:
        ----------------------------------------
import json
from pathlib import Path

def load_audio_parameters():
    current_dir = Path(__file__).resolve().parent
    json_path = current_dir.parent / 'config' / 'audio_parameters.json'
    
    with open(json_path, 'r') as f:
        return json.load(f)

audio_parameters = load_audio_parameters()
audio_parameters['HOP_LENGTH'] = int(audio_parameters['BLOCKSIZE'] / 2)
        ----------------------------------------

        interface.py

        Content of interface.py:
        ----------------------------------------
"""
interface.py

Description: This script provides a command line interface for toggling light mappings and controlling the Spotify API.

Author: Landry Bulls
Date: 8/20/24
"""

import curses
import keyboard
from audio import AudioListener
from control import LightController, SceneManager
import time

oculizer_title = """
      ___           ___           ___           ___                   ___           ___           ___     
     /\  \         /\  \         /\__\         /\__\      ___        /\  \         /\  \         /\  \    
    /::\  \       /::\  \       /:/  /        /:/  /     /\  \       \:\  \       /::\  \       /::\  \   
   /:/\:\  \     /:/\:\  \     /:/  /        /:/  /      \:\  \       \:\  \     /:/\:\  \     /:/\:\  \  
  /:/  \:\  \   /:/  \:\  \   /:/  /  ___   /:/  /       /::\__\       \:\  \   /::\~\:\  \   /::\~\:\  \ 
 /:/__/ \:\__\ /:/__/ \:\__\ /:/__/  /\__\ /:/__/     __/:/\/__/ _______\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ 
 \:\  \ /:/  / \:\  \  \/__/ \:\  \ /:/  / \:\  \    /\/:/  /    \::::::::/__/ \:\~\:\ \/__/ \/_|::\/:/  /
  \:\  /:/  /   \:\  \        \:\  /:/  /   \:\  \   \::/__/      \:\~~\~~      \:\ \:\__\      |:|::/  / 
   \:\/:/  /     \:\  \        \:\/:/  /     \:\  \   \:\__\       \:\  \        \:\ \/__/      |:|\/__/  
    \::/  /       \:\__\        \::/  /       \:\__\   \/__/        \:\__\        \:\__\        |:|  |    
     \/__/         \/__/         \/__/         \/__/                 \/__/         \/__/         \|__|    
"""

def main(stdscr):
    scene_manager = SceneManager('scenes_directory', 'profiles_directory')
    audio_listener = AudioListener()
    dmx_controller = Controller()
    light_controller = LightController(audio_listener, dmx_controller, scene_manager)

    audio_listener.start()
    light_controller.start()

    scenes = list(scene_manager.scenes.keys())
    current_scene_index = 0

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, oculizer_title)
        stdscr.addstr(1, 0, f"Current scene: {scenes[current_scene_index]}")
        stdscr.addstr(2, 0, "Press 'n' for next scene, 'p' for previous scene, 'q' to quit")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('n'):
            current_scene_index = (current_scene_index + 1) % len(scenes)
            scene_manager.set_scene(scenes[current_scene_index])
        elif key == ord('p'):
            current_scene_index = (current_scene_index - 1) % len(scenes)
            scene_manager.set_scene(scenes[current_scene_index])
        elif key == ord('q'):
            break

    audio_listener.stop()
    light_controller.stop()
    audio_listener.join()
    light_controller.join()

if __name__ == "__main__":
    curses.wrapper(main)



        ----------------------------------------

        __init__.py

        Content of __init__.py:
        ----------------------------------------
from oculizer.audio import AudioListener
from oculizer.light import Oculizer
from oculizer.light import mapping
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer
from oculizer.config import audio_parameters
from oculizer.custom_profiles.RGB import RGB
from oculizer.custom_profiles.ADJ_strobe import Strobe
from oculizer import utils
        ----------------------------------------

        utils.py

        Content of utils.py:
        ----------------------------------------
import os
import json

def load_json(filename):
    with open(filename, 'r') as f:
        data = json.load(f)
    return data
        ----------------------------------------

        visualizer.py

        Content of visualizer.py:
        ----------------------------------------
import sys
import numpy as np
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
from PyQt5.QtCore import QTimer
import pyqtgraph as pg
from oculizer import Oculizer, SceneManager
from oculizer.config import audio_parameters

nmfft = audio_parameters['NMFFT']

class FeatureVisualizer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("mfft Feature Visualizer")
        self.setGeometry(100, 100, 1000, 800)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.coeff_plot = pg.PlotWidget(title='Mel-scaled FFT Coefficients')
        layout.addWidget(self.coeff_plot)

        self.coeff_bars = pg.BarGraphItem(x=range(nmfft), height=[0]*nmfft, width=0.8, brush='b')
        self.coeff_plot.addItem(self.coeff_bars)

        self.coeff_plot.setLabel('left', 'Magnitude')
        self.coeff_plot.setLabel('bottom', 'mfft Coefficient')
        self.coeff_plot.showGrid(y=True)
        self.coeff_plot.setYRange(0, 20)  # Adjust based on your typical coefficient values
        self.coeff_plot.setXRange(-0.5, nmfft+0.5)
        x_axis = self.coeff_plot.getAxis('bottom')
        x_axis.setTicks([[(i, str(i+1)) if (i+1) % 5 == 0 else (i, '') for i in range(nmfft)]])
        x_axis.setStyle(tickTextOffset=10, tickLength=-15)

        # Initialize Oculizer controller
        scene_manager = SceneManager('scenes')
        self.controller = Oculizer('testing', scene_manager)
        self.controller.start()

        # Set up timer for updating plots
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(10)  # Update every 10 ms

    def update_plot(self):
        mfft = self.controller.mfft_queue.get()
        if mfft is not None and len(mfft) == nmfft:
            self.coeff_bars.setOpts(height=mfft)

    def closeEvent(self, event):
        self.controller.stop()
        self.controller.join()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    visualizer = FeatureVisualizer()
    visualizer.show()
    sys.exit(app.exec_())
        ----------------------------------------

        custom_profiles/
            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .ADJ_strobe import Strobe
from .RGB import RGB
            ----------------------------------------

            ADJ_strobe.py

            Content of ADJ_strobe.py:
            ----------------------------------------
from PyDMXControl.profiles.defaults import Fixture

class Strobe(Fixture):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._register_channel('dimmer')
        self._register_channel_aliases('dimmer', 'brightness', 'dim', 'd')
        self._register_channel('strobe')
        self._register_channel_aliases('strobe', 's')
        self._register_channel('function')
            ----------------------------------------

            RGB.py

            Content of RGB.py:
            ----------------------------------------
from PyDMXControl.profiles.defaults import Fixture

class RGB(Fixture):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._register_channel('dimmer')
        self._register_channel_aliases('dimmer', 'brightness', 'dim', 'd')
        self._register_channel('red')
        self._register_channel_aliases('red', 'r')
        self._register_channel('green')
        self._register_channel_aliases('green', 'g')
        self._register_channel('blue')
        self._register_channel_aliases('blue', 'b')
        self._register_channel('strobe')
        self._register_channel_aliases('strobe', 's')
        self._register_channel('function')

    def set_color(self, color):
        if color == 'red':
            self.set_channels(self.get_channels()[0], 255, 0, 0)
        elif color == 'orange':
            self.set_channels(self.get_channels()[0], 255, 127, 0)
        elif color == 'yellow':
            self.set_channels(self.get_channels()[0], 255, 255, 0)
        elif color == 'green':
            self.set_channels(self.get_channels()[0], 0, 255, 0)
        elif color == 'blue':
            self.set_channels(self.get_channels()[0], 0, 0, 255)
        elif color == 'purple':
            self.set_channels(self.get_channels()[0], 75, 0, 130)
        elif color == 'pink':
            self.set_channels(self.get_channels()[0], 255, 0, 255)
        elif color == 'white':
            self.set_channels(self.get_channels()[0], 255, 255, 255)
        else:
            raise ValueError(f"Color '{color}' not found")

    def set_strobe(self, speed, brightness):
        self.set_channels(255, 255, 255, speed, brightness, 0, 0)

            ----------------------------------------

        scenes/
            scene_manager.py

            Content of scene_manager.py:
            ----------------------------------------
import os
import json

class SceneManager:
    def __init__(self, scenes_directory):
        # two dirs up from the current file
        scenes_directory = os.path.join(os.path.dirname(__file__), '..', '..', scenes_directory)
        self.scenes = self.load_json_files(scenes_directory)
        self.current_scene = self.scenes[list(self.scenes.keys())[0]]

    def load_json_files(self, directory):
        data = {}
        for filename in os.listdir(directory):
            if filename.endswith('.json'):
                with open(os.path.join(directory, filename), 'r') as file:
                    data[filename[:-5]] = json.load(file)
        return data

    def set_scene(self, scene_name):
        if scene_name in self.scenes:
            self.current_scene = self.scenes[scene_name]
        else:
            raise ValueError(f"Scene '{scene_name}' not found")

    def reload_scenes(self):
        self.scenes = self.load_json_files('scenes')

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('testing')
    print(scene_manager.current_scene)

if __name__ == '__main__':
    main()
            ----------------------------------------

            scene_prediction.py

            Content of scene_prediction.py:
            ----------------------------------------
"""
Predict the lighting scene based on spotify features, real-time audio analysis, and user preferences. 
"""

import numpy as np
from scipy.spatial import distance
import time
import threading
import queue
import json
import os
import random
from config import audio_parameters
import librosa
from sklearn.cluster import KMeans


            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .scene_manager import SceneManager
            ----------------------------------------

        spotify/
            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .spotifizer import Spotifizer
            ----------------------------------------

            spotifizer.py

            Content of spotifizer.py:
            ----------------------------------------
"""
Description: Provides Spotifizer class which runs a thread to continuously pull song info from Spotify API.
Must have a Spotify Premium account, the app on the same device, have set up the app, etc. 
"""

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials, SpotifyOAuth
import threading
import queue
import time
import curses
import os

# get the client id and client secret from the text file
# get the client id and client secret from the text file
credspath = os.path.join(os.path.dirname(__file__), '../../spotify_credentials.txt')
with open(credspath) as f:
    client_id = f.readline().strip().split(' ')[1]
    client_secret = f.readline().strip().split(' ')[1]
    uri = f.readline().split(' ')[1][:-1]
    username = f.readline().split(' ')[1][:-1]
    #token = f.readline().split(' ')[1][:-1]

# set the environment variables
os.environ['SPOTIPY_CLIENT_ID'], os.environ['SPOTIFY_CLIENT_ID'] = client_id, client_id
os.environ['SPOTIPY_CLIENT_SECRET'], os.environ['SPOTIFY_CLIENT_SECRET'] = client_secret, client_secret
os.environ['SPOTIPY_REDIRECT_URI'], os.environ['SPOTIFY_REDIRECT_URI'] = uri, uri

auth_manager = SpotifyClientCredentials()
sp = spotipy.Spotify(auth_manager=auth_manager)

# just add all the scopes
scopes = ['user-library-read',
            'user-read-recently-played',
            'user-top-read',
            'user-follow-read',
            'user-read-playback-position',
            'user-read-playback-state',
            'user-read-currently-playing',
            'user-modify-playback-state',
            'user-read-private',
            'playlist-read-private',
            'playlist-read-collaborative',
            'playlist-modify-public',
            'playlist-modify-private']

token = SpotifyOAuth(scope=' '.join(scopes)).get_access_token(as_dict=False)

if token:
    sp = spotipy.Spotify(auth=token)
    saved_tracks_resp = sp.current_user_saved_tracks(limit=50)
else:
    print('Couldn\'t get token for that username')

user = sp.user(username)
sp.user = user

class Spotifizer(threading.Thread):
    def __init__(self, update_interval=0.1):
        super().__init__()
        self.running = threading.Event()
        self.error_queue = queue.Queue()
        self.info_queue = queue.Queue()
        self.spotify = sp
        self.playing = False
        self.volume = 0
        self.current_track_id = None
        self.current_track_info = None 
        self.artist = None
        self.title = None
        self.update_interval = update_interval
        self.progress = 0
        self.suggested_scene = 'testing'

    def run(self):
        self.running.set()
        try:
            while self.running.is_set():
                self.update_current_track()
        except Exception as e:
            self.error_queue.put(f"Error in Spotifizer: {str(e)}")

    def update_current_track(self):
        current_playback = self.spotify.current_playback()
        if current_playback is not None:
            if current_playback['is_playing']:
                self.playing = True
                self.current_track_id = current_playback['item']['id']
                self.current_track_info = current_playback['item']
                self.artist = current_playback['item']['artists'][0]['name']
                self.title = current_playback['item']['name']
                self.volume = current_playback['device']['volume_percent']
                self.progress = current_playback['progress_ms'] + 500
        else:
            self.playing = False
            self.current_track_id = None
            self.current_track_info = None

    def play(self):
        try:
            if not self.playing:
                self.spotify.start_playback()
                self.playing = True
        except Exception as e:
            self.error_queue.put(f"Error playing in Spotifizer: {str(e)}")

    def pause(self):
        try:
            if self.playing:
                self.spotify.pause_playback()
                self.playing = False
        except Exception as e:
            self.error_queue.put(f"Error pausing in Spotifizer: {str(e)}")

    def quiet(self, volume=50):
        try:
            self.spotify.volume(volume)
        except Exception as e:
            self.error_queue.put(f"Error setting volume in Spotifizer: {str(e)}")

    def loud(self, volume=100):
        try:
            self.spotify.volume(volume)
        except Exception as e:
            self.error_queue.put(f"Error setting volume in Spotifizer: {str(e)}")

    def next(self):
        try:
            self.spotify.next_track()
        except Exception as e:
            self.error_queue.put(f"Error playing next track in Spotifizer: {str(e)}")

    def previous(self):
        try:
            self.spotify.previous_track()
        except Exception as e:
            self.error_queue.put(f"Error playing previous track in Spotifizer: {str(e)}")

    def stop(self):
        self.running.clear()


def main():
    stdscr = curses.initscr()
    spotifizer = Spotifizer()
    spotifizer.start()
    spotifizer.pause()
    spotifizer.spotify.volume(50)
    if not spotifizer.spotify.current_playback()['is_playing']:
        spotifizer.play()
    print('Listening to Spotify...')
    try:
        while True:
            if spotifizer.current_track_info is not None:
                stdscr.clear()
                stdscr.addstr(0, 0, f"Track: {spotifizer.title}")
                stdscr.addstr(1, 0, f"Artist: {spotifizer.artist}")
                stdscr.addstr(2, 0, f"Playing: {spotifizer.playing}")
                stdscr.addstr(3, 0, f"Volume: {spotifizer.volume}")
                stdscr.addstr(4, 0, f"Progress_ms: {spotifizer.progress}")
                stdscr.refresh()
            else:
                stdscr.addstr(0, 0, "No track playing...")
                stdscr.refresh()

    except KeyboardInterrupt:
        spotifizer.stop()
        print('Stopped listening to Spotify...')
        time.sleep(1)
    
    finally:

        spotifizer.join()
        curses.endwin()

if __name__ == "__main__":
    main()

            ----------------------------------------

        audio/
            audio_listener.py

            Content of audio_listener.py:
            ----------------------------------------
import threading
import queue
import numpy as np
from scipy.fftpack import rfft
import time
import curses
import sounddevice as sd
from oculizer.config import audio_parameters

SAMPLERATE = audio_parameters['SAMPLERATE']
BLOCKSIZE = audio_parameters['BLOCKSIZE']

def get_blackhole_device_idx():
    devices = sd.query_devices()
    for i, device in enumerate(devices):
        if 'BlackHole' in device['name']:
            return i, device['name']
    return None, None

class AudioListener(threading.Thread):
    def __init__(self, sample_rate=SAMPLERATE, block_size=BLOCKSIZE, channels=1):
        threading.Thread.__init__(self)
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.channels = channels
        self.audio_queue = queue.Queue()
        self.fft_queue = queue.Queue()
        self.running = threading.Event()
        self.error_queue = queue.Queue()
        self.device_idx, self.device_name = get_blackhole_device_idx()
        self.stream = None

    def audio_callback(self, indata, frames, time, status):
        if status:
            self.error_queue.put(f"Audio callback error: {status}")
        try:
            audio_data = indata.copy().flatten()
            fft_data = np.abs(rfft(audio_data))
            self.audio_queue.put(audio_data)
            self.fft_queue.put(fft_data)
        except Exception as e:
            self.error_queue.put(f"Error processing audio data: {str(e)}")

    def run(self):
        self.running.set()
        try:
            with sd.InputStream(
                device=self.device_idx,
                channels=self.channels,
                samplerate=self.sample_rate,
                blocksize=self.block_size,
                callback=self.audio_callback
            ):
                while self.running.is_set():
                    sd.sleep(100)
        except Exception as e:
            self.error_queue.put(f"Error in audio stream: {str(e)}")

    def stop(self):
        self.running.clear()

    def get_audio_data(self):
        try:
            return self.audio_queue.get_nowait()
        except queue.Empty:
            return None

    def get_fft_data(self, timeout=0.08):
        try:
            return self.fft_queue.get(timeout=timeout)
        except queue.Empty:
            return None

    def get_errors(self):
        errors = []
        while not self.error_queue.empty():
            errors.append(self.error_queue.get_nowait())
        return errors

def main():
    stdscr = curses.initscr()

    audio_listener = AudioListener()
    audio_listener.start()
    print('Listening to audio...')

    try:
        while True:
            audio_data = audio_listener.get_audio_data()
            fft_data = audio_listener.get_fft_data()
            errors = audio_listener.get_errors()
            
            stdscr.clear()
            if fft_data is not None:
                stdscr.addstr(0, 1, f"FFT Sum: {np.sum(fft_data)}")
                stdscr.addstr(1, 1, f'FFT Shape: {len(fft_data)}')
            stdscr.addstr(2, 1, f"Sample rate: {audio_listener.sample_rate}")
            stdscr.addstr(3, 1, f"Block size: {audio_listener.block_size}")
            stdscr.refresh()

            if errors:
                print("Errors occurred:", errors)

            if audio_data is not None and fft_data is not None:
                # Process data here
                pass

            time.sleep(0.01)  # Small delay to prevent busy-waiting
    except KeyboardInterrupt:
        print("Stopping audio listener...")
    finally:
        audio_listener.stop()
        audio_listener.join()
        curses.endwin()

if __name__ == "__main__":
    main()
            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .audio_listener import AudioListener

            ----------------------------------------

        light/
            control.py

            Content of control.py:
            ----------------------------------------
"""
light_control.py

Description: This script provides all the lighting control. It is responsible for controlling the DMX lights and RGB lights, loading profiles, 
setting up the DMX controller, providing functions for sending signals to the DMX controller, and providing functions for controlling the RGB lights.

Author: Landry Bulls
Date: 8/20/24
"""

import numpy as np
import sounddevice as sd
from librosa.feature import melspectrogram
from PyDMXControl.controllers import OpenDMXController
from PyDMXControl.profiles.Generic import Dimmer, Custom
from oculizer.custom_profiles.RGB import RGB
from oculizer.custom_profiles.ADJ_strobe import Strobe
from oculizer.scenes import SceneManager
from oculizer.light.mapping import process_light, scale_mfft
from oculizer.config import audio_parameters
from oculizer.utils import load_json
import threading
import queue
import time
from pathlib import Path

class Oculizer(threading.Thread):
    def __init__(self, profile_name, scene_manager):
        threading.Thread.__init__(self)
        self.profile_name = profile_name
        self.sample_rate = audio_parameters['SAMPLERATE']
        self.block_size = audio_parameters['BLOCKSIZE']
        self.hop_length = audio_parameters['HOP_LENGTH']
        self.channels = 1
        self.mfft_queue = queue.Queue(maxsize=1)
        self.device_idx = self._get_blackhole_device_idx()
        self.running = threading.Event()
        self.scene_manager = scene_manager
        self.profile = self._load_profile()
        self.light_names = [i['name'] for i in self.profile['lights']]
        self.dmx_controller, self.controller_dict = self._load_controller()
        self.scene_changed = threading.Event()

    def _get_blackhole_device_idx(self):
        devices = sd.query_devices()
        for i, device in enumerate(devices):
            if 'BlackHole' in device['name']:
                return i
        return None

    def _load_profile(self):
        current_dir = Path(__file__).resolve().parent
        project_root = current_dir.parent.parent
        profile_path = project_root / 'profiles' / f'{self.profile_name}.json'
        return load_json(profile_path)

    def _load_controller(self):
        controller = OpenDMXController()
        control_dict = {}
        curr_channel = 1
        sleeptime = 0.1

        for light in self.profile['lights']:
            if light['type'] == 'dimmer':
                control_dict[light['name']] = controller.add_fixture(Dimmer(name=light['name'], start_channel=curr_channel))
                curr_channel += 1
                control_dict[light['name']].dim(255)
                time.sleep(sleeptime)
                control_dict[light['name']].dim(0)

            elif light['type'] == 'rgb':
                control_dict[light['name']] = controller.add_fixture(RGB(name=light['name'], start_channel=curr_channel))
                curr_channel += 6
                control_dict[light['name']].set_channels([255, 255, 255, 255, 255, 0])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0, 0, 0, 0, 0, 0])

            elif light['type'] == 'strobe':
                control_dict[light['name']] = controller.add_fixture(Strobe(name=light['name'], start_channel=curr_channel))
                curr_channel += 2
                control_dict[light['name']].set_channels([255, 255])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0, 0])

            elif light['type'] == 'laser':
                control_dict[light['name']] = controller.add_fixture(Custom(name=light['name'], start_channel=curr_channel, channels=10))
                curr_channel += 10
                control_dict[light['name']].set_channels([128, 0, 0, 0, 0, 0, 0, 0, 0, 0])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0] * 10)
                time.sleep(sleeptime)

        return controller, control_dict

    def audio_callback(self, indata, frames, time, status):
        if status:
            print(f"Audio callback error: {status}")
            return
        
        audio_data = indata.copy().flatten()
        mfft_data = np.mean(melspectrogram(y=audio_data, sr=self.sample_rate, n_fft=self.block_size, hop_length=self.hop_length), axis=1)
        mfft_data = scale_mfft(mfft_data)
        
        if self.mfft_queue.full():
            try:
                self.mfft_queue.get_nowait()
            except queue.Empty:
                pass
        self.mfft_queue.put(mfft_data)

    def run(self):
        self.running.set()
        try:
            with sd.InputStream(
                device=self.device_idx,
                channels=self.channels,
                samplerate=self.sample_rate,
                blocksize=self.block_size,
                callback=self.audio_callback
            ):
                while self.running.is_set():
                    self.process_audio_and_lights()
                    time.sleep(0.001)
        except Exception as e:
            print(f"Error in audio stream: {str(e)}")
            print(f"Origin script: {e.__traceback__.tb_frame.f_globals['__file__']}")    

    def process_audio_and_lights(self):
        if self.scene_changed.is_set():
            self.scene_changed.clear()
            self.turn_off_all_lights()

        try:
            mfft_data = self.mfft_queue.get(block=False)
        except queue.Empty:
            return

        current_time = time.time()

        for light in self.scene_manager.current_scene['lights']:
            if light['name'] not in self.light_names:
                continue

            try:
                dmx_values = process_light(light, mfft_data, current_time)
                if dmx_values is not None:
                    if light['type'] == 'dimmer':
                        self.controller_dict[light['name']].dim(dmx_values[0])

                    elif light['type'] == 'rgb':
                        self.controller_dict[light['name']].set_channels(dmx_values[:6])

                    elif light['type'] == 'strobe':
                        self.controller_dict[light['name']].set_channels(dmx_values[:2])

                    elif light['type'] == 'laser':
                        self.controller_dict[light['name']].set_channels(dmx_values[:10])

            except Exception as e:
                print(f"Error processing light {light['name']}: {str(e)}")


    def change_scene(self, scene_name):
        self.scene_manager.set_scene(scene_name)
        self.scene_changed.set()

    def turn_off_all_lights(self):
        for light in self.profile['lights']:
            if light['type'] == 'dimmer':
                self.controller_dict[light['name']].dim(0)
            elif light['type'] == 'rgb':
                self.controller_dict[light['name']].set_channels([0, 0, 0, 0, 0, 0])
            elif light['type'] == 'strobe':
                self.controller_dict[light['name']].set_channels([0, 0])

    def stop(self):
        self.running.clear()

def main():
    # init scene manager
    scene_manager = SceneManager('scenes')
    # set the initial scene to the test scene
    scene_manager.set_scene('testing')  
    # init the light controller with the name of the profile and the scene manager
    controller = Oculizer('testing', scene_manager)
    print("Starting Oculizer...")
    controller.start()
    
    try:
        while True:
            time.sleep(1)  # Main thread does nothing but keep the program alive
    except KeyboardInterrupt:
        print("Stopping Oculizer...")
        controller.stop()
        controller.join()

if __name__ == "__main__":
    main()







            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
#from .control import load_controller, load_json, load_profile, Oculizer
from .control import Oculizer

            ----------------------------------------

            mapping.py

            Content of mapping.py:
            ----------------------------------------
import numpy as np
import time
from oculizer.config import audio_parameters

SAMPLERATE = audio_parameters['SAMPLERATE']
BLOCKSIZE = audio_parameters['BLOCKSIZE']

COLORS = np.array([
    [255, 0, 0],    # red
    [255, 127, 0],  # orange
    [255, 255, 0],  # yellow
    [0, 255, 0],    # green
    [0, 0, 255],    # blue
    [75, 0, 130],   # purple
    [255, 0, 255],  # pink
    [255, 255, 255] # white
], dtype=np.int32)

COLOR_NAMES = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink', 'white']

def scale_mfft(mfft_vec, scaling_factor=10.0, scaling_method='log'):
    num_bins = len(mfft_vec)
    if scaling_method == 'log':
        scaling = np.log1p(np.arange(num_bins) / num_bins) * scaling_factor + 1
    elif scaling_method == 'exp':
        scaling = np.exp(np.arange(num_bins) / num_bins * scaling_factor)
    elif scaling_method == 'linear':
        scaling = np.linspace(1, 1 + scaling_factor, num_bins)
    else:
        raise ValueError("Invalid scaling method. Choose 'log', 'exp', or 'linear'.")
    scaling /= scaling.mean()
    return mfft_vec * scaling

def color_to_rgb(color_name):
    return COLORS[COLOR_NAMES.index(color_name)] if color_name in COLOR_NAMES else COLORS[np.random.randint(0, len(COLOR_NAMES))]

def freq_to_index(freq):
    return int(freq * BLOCKSIZE / SAMPLERATE)

def power_to_brightness(power, power_range, brightness_range):
    power_low, power_high = power_range
    brightness_low, brightness_high = brightness_range
    if power <= power_low:
        return brightness_low
    elif power >= power_high:
        return brightness_high
    else:
        return int((power - power_low) / (power_high - power_low) * (brightness_high - brightness_low) + brightness_low)

def mfft_to_value(mfft_vec, mfft_range, power_range, value_range):
    mfft_low, mfft_high = int(mfft_range[0]), int(mfft_range[1])
    if mfft_low < 0 or mfft_high > len(mfft_vec):
        raise ValueError(f"MFFT range {mfft_range} is out of bounds for MFFT vector of length {len(mfft_vec)}")
    mfft_mean = np.mean(mfft_vec[mfft_low:mfft_high])
    return power_to_brightness(mfft_mean, power_range, value_range)

def time_function(t, frequency, function):
    functions = {
        'sine': lambda t, f: np.sin(t * f * 2 * np.pi) * 0.5 + 0.5,
        'square': lambda t, f: np.sign(np.sin(t * f * 2 * np.pi)) * 0.5 + 0.5,
        'triangle': lambda t, f: np.abs(((t * f) % 2) - 1),
        'sawtooth_forward': lambda t, f: (t * f) % 1,
        'sawtooth_backward': lambda t, f: 1 - (t * f % 1)
    }
    return functions.get(function, functions['sine'])(t, frequency)

def process_mfft(light, mfft_vec):
    mfft_range = light.get('mfft_range', (0, len(mfft_vec)))
    power_range = light.get('power_range', (0, 1))
    value_range = light.get('brightness_range', (0, 255))
    
    if light['type'] == 'dimmer':
        return [mfft_to_value(mfft_vec, mfft_range, power_range, value_range)]
    elif light['type'] == 'rgb':
        brightness = mfft_to_value(mfft_vec, mfft_range, power_range, value_range)
        color = color_to_rgb(light.get('color', 'random'))
        strobe = light.get('strobe', 0)
        return [brightness, *color, strobe, 0]
    elif light['type'] == 'strobe':
        threshold = light.get('threshold', 0.5)
        mfft_mean = np.mean(mfft_vec[mfft_range[0]:mfft_range[1]])
        return [255, 255] if mfft_mean >= threshold else [0, 0]
    elif light['type'] == 'laser':
        zoom_range = light.get('zoom_range', [0, 127])
        speed_range = light.get('speed_range', [0, 255])
        mfft_power = np.mean(mfft_vec)
        channels = [0] * 10
        channels[0] = 0
        if mfft_power <= power_range[0]:
            channels[1], channels[3], channels[9] = 0, zoom_range[0], speed_range[0]
        else:
            channels[1], channels[2] = 255, np.random.randint(0, 256)
            if mfft_power >= power_range[1]:
                channels[3], channels[9] = zoom_range[1], speed_range[1]
            else:
                power_ratio = (mfft_power - power_range[0]) / (power_range[1] - power_range[0])
                channels[3] = int(zoom_range[0] + power_ratio * (zoom_range[1] - zoom_range[0]))
                channels[9] = int(speed_range[0] + power_ratio * (speed_range[1] - speed_range[0]))
        return channels

def process_bool(light):
    if light['type'] == 'dimmer':
        if light['brightness']=='random':
            brightness = np.random.randint(light.get('min_brightness', 0), light.get('max_brightness', 255) + 1)
        else:
            brightness = light.get('brightness', 255)
        return [brightness]
    elif light['type'] == 'rgb':
        brightness = np.random.randint(0, 256) if light.get('brightness', 'random') == 'random' else light.get('brightness', 255)
        color = color_to_rgb(light.get('color', 'random'))
        strobe = np.random.randint(0, 256) if light.get('strobe', 'random') == 'random' else light.get('strobe', 0)
        colorfade = light.get('colorfade', 0)
        return [brightness, *color, strobe, colorfade]
    elif light['type'] == 'strobe':
        speed = np.random.randint(0, 256) if light.get('speed', 'random') == 'random' else light.get('speed', 255)
        brightness = np.random.randint(0, 256) if light.get('brightness', 'random') == 'random' else light.get('brightness', 255)
        return [speed, brightness]
    elif light['type'] == 'laser':
        return [128, 255] + [0] * 8

def time_function(t, frequency, function):
    functions = {
        'sine': lambda t, f: np.sin(t * f * 2 * np.pi) * 0.5 + 0.5,
        'square': lambda t, f: np.sign(np.sin(t * f * 2 * np.pi)) * 0.5 + 0.5,
        'triangle': lambda t, f: np.abs(((t * f) % 2) - 1),
        'sawtooth_forward': lambda t, f: (t * f) % 1,
        'sawtooth_backward': lambda t, f: 1 - (t * f % 1)
    }
    
    # Convert integer input to corresponding string
    if isinstance(function, int):
        function_names = list(functions.keys())
        if 0 <= function < len(function_names):
            function = function_names[function]
        else:
            function = 'sine'  # Default to sine if integer is out of range
    
    # Use the specified function or default to sine
    return functions.get(function, functions['sine'])(t, frequency)

def process_time(light, current_time):
    t = current_time
    frequency = light.get('frequency', 1)
    function = light.get('function', 'sine')
    min_value = light.get('min_brightness', 0)
    max_value = light.get('max_brightness', 255)
    value = int(min_value + (max_value - min_value) * time_function(t, frequency, function))
    
    if light['type'] == 'dimmer':
        return [value]
    elif light['type'] == 'rgb':
        color = color_to_rgb(light.get('color', 'random'))
        strobe = light.get('strobe', 0)
        return [value, *color, strobe, 0]
    elif light['type'] == 'strobe':
        target = light.get('target', 'both')
        speed_range = light.get('speed_range', [0, 255])
        brightness_range = light.get('brightness_range', [0, 255])
        if target == 'speed':
            return [value, brightness_range[1]]
        elif target == 'brightness':
            return [speed_range[1], value]
        else:
            speed = int(speed_range[0] + (speed_range[1] - speed_range[0]) * time_function(t, frequency, function))
            brightness = int(brightness_range[0] + (brightness_range[1] - brightness_range[0]) * time_function(t, frequency, function))
            return [speed, brightness]

def process_light(light, mfft_vec, current_time):
    modulator = light.get('modulator', 'bool')
    
    if modulator == 'mfft':
        return process_mfft(light, mfft_vec)
    elif modulator == 'bool':
        return process_bool(light)
    elif modulator == 'time':
        return process_time(light, current_time)
    
    return None

def main():
    mfft_data = np.random.rand(128)
    light = {
        'modulator': 'mfft',
        'type': 'rgb',
        'mfft_range': (0, 128),
        'power_range': (0, 1),
        'brightness_range': (0, 255),
        'color': 'random',
        'strobe': 0
    }
    dmx_values = process_light(light, mfft_data, time.time())
    print(dmx_values)

if __name__ == "__main__":
    main()




            ----------------------------------------
