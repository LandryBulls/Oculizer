Oculizer/
    get_song_data.py

    Content of get_song_data.py:
    ----------------------------------------
import os
import json
import time
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials

# Spotify API rate limit is 1000 requests per 5 minutes
# We'll use a conservative limit of 100 requests per minute
RATE_LIMIT = 100
RATE_LIMIT_WINDOW = 60  # seconds

def load_credentials():
    credspath = os.path.join(os.path.dirname(__file__), 'spotify_credentials.txt')
    with open(credspath) as f:
        lines = f.readlines()
        client_id = lines[0].strip().split(' ')[1]
        client_secret = lines[1].strip().split(' ')[1]
    return client_id, client_secret

def get_playlist_tracks(sp, playlist_id):
    results = sp.playlist_tracks(playlist_id)
    tracks = results['items']
    while results['next']:
        results = sp.next(results)
        tracks.extend(results['items'])
    return tracks

def fetch_audio_analysis(sp, track):
    track_id = track['track']['id']
    track_name = track['track']['name']
    track_artists = track['track']['artists'][0]['name']
    filename = f"song_data/{track_id}.json"
    
    if os.path.exists(filename):
        print(f"Audio analysis for track '{track_name}' (ID: {track_id}) already exists. Skipping.")
        return None

    try:
        analysis = sp.audio_analysis(track_id)
        # Add track name to the analysis data
        analysis['track'] = analysis.get('track', {})
        analysis['track']['name'] = track_name
        analysis['track']['artists'] = track_artists
        return analysis
    except Exception as e:
        print(f"Error fetching audio analysis for track '{track_name}' (ID: {track_id}): {str(e)}")
        return None

def save_audio_analysis(track_id, analysis):
    if not os.path.exists('song_data'):
        os.makedirs('song_data')
    
    filename = f"song_data/{track_id}.json"
    if os.path.exists(filename):
        print(f"Audio analysis for track '{analysis['track']['name']}' (ID: {track_id}) already exists. Not overwriting.")
        
    else:
        with open(filename, 'w') as f:
            json.dump(analysis, f, indent=2)
        print(f"Saved audio analysis for track '{analysis['track']['name']}' (ID: {track_id})")

def analyze_playlist(playlist_url):
    client_id, client_secret = load_credentials()
    client_credentials_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
    sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

    playlist_id = playlist_url.split('/')[-1].split('?')[0]
    tracks = get_playlist_tracks(sp, playlist_id)

    request_count = 0
    start_time = time.time()

    for item in tracks:
        if request_count >= RATE_LIMIT:
            elapsed = time.time() - start_time
            if elapsed < RATE_LIMIT_WINDOW:
                sleep_time = RATE_LIMIT_WINDOW - elapsed
                print(f"Rate limit reached. Sleeping for {sleep_time:.2f} seconds")
                time.sleep(sleep_time)
            start_time = time.time()
            request_count = 0

        analysis = fetch_audio_analysis(sp, item)
        if analysis:
            save_audio_analysis(item['track']['id'], analysis)
            request_count += 1

    print("Finished analyzing playlist")

if __name__ == "__main__":
    playlist_url = input("Enter the Spotify playlist URL: ")
    analyze_playlist(playlist_url)

    ----------------------------------------

    run_garage.py

    Content of run_garage.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('blue')
    light_controller = Oculizer('garage', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")

        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    run_laser.py

    Content of run_laser.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('laser')
    light_controller = Oculizer('laser', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    run_full.py

    Content of run_full.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('hell')
    light_controller = Oculizer('garage', scene_manager)
    spotifizer = Spotifizer()

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()
    spotifizer.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
            
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")e
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    oculize.py

    Content of oculize.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import mido
from collections import OrderedDict

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer

def create_midi_scene_map(scenes):
    midi_scene_map = {}
    for scene_name, scene_data in scenes.items():
        if 'midi' in scene_data:
            midi_scene_map[scene_data['midi']] = scene_name
    return midi_scene_map

def sort_scenes_by_midi(scenes):
    scene_list = [(data.get('midi', float('inf')), name, data) for name, data in scenes.items()]
    sorted_scenes = sorted(scene_list, key=lambda x: x[0])
    return OrderedDict((name, data) for _, name, data in sorted_scenes)

def init_colors():
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_BLUE, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)
    curses.init_pair(6, curses.COLOR_CYAN, -1)
    curses.init_pair(7, curses.COLOR_WHITE, -1)
    curses.init_pair(8, curses.COLOR_BLACK, curses.COLOR_WHITE)  # For highlighting

class SpotifySceneController(threading.Thread):
    def __init__(self, scene_manager, light_controller, spotify_credentials):
        threading.Thread.__init__(self)
        self.scene_manager = scene_manager
        self.light_controller = light_controller
        self.spotifizer = Spotifizer(*spotify_credentials)
        self.running = threading.Event()
        self.last_section_change = 0
        self.section_change_cooldown = 5  # Cooldown period in seconds

    def run(self):
        self.running.set()
        self.spotifizer.start()
        while self.running.is_set():
            self.check_spotify_section()
            time.sleep(0.1)

    def check_spotify_section(self):
        with self.spotifizer.section_lock:
            current_section = self.spotifizer.current_section
        
        if self.spotifizer.playing and current_section:
            current_time = time.time()
            if current_time - self.last_section_change > self.section_change_cooldown:
                new_scene = self.select_scene_based_on_section(current_section)
                if new_scene != self.scene_manager.current_scene['name']:
                    self.light_controller.change_scene(new_scene)
                    self.last_section_change = current_time

    def select_scene_based_on_section(self, section):
        loudness = section.get('loudness', -60)
        tempo = section.get('tempo', 120)

        if loudness > -5 and tempo > 150:
            return 'drop1'
        elif loudness > -10 and tempo > 120:
            return 'build1'
        else:
            return 'ambient1'

    def stop(self):
        self.running.clear()
        self.spotifizer.stop()
        self.spotifizer.join()

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('party')  # Set an initial scene
    light_controller = Oculizer('garage', scene_manager)

    scene_manager.scenes = sort_scenes_by_midi(scene_manager.scenes)
    midi_scene_map = create_midi_scene_map(scene_manager.scenes)

    light_controller.start()

    # Read Spotify credentials
    credspath = os.path.join(os.path.dirname(__file__), '../../spotify_credentials.txt')
    with open(credspath) as f:
        lines = f.readlines()
        client_id = lines[0].strip().split(' ')[1]
        client_secret = lines[1].strip().split(' ')[1]
        redirect_uri = lines[2].strip().split(' ')[1]
    
    spotify_credentials = (client_id, client_secret, redirect_uri)
    spotify_controller = SpotifySceneController(scene_manager, light_controller, spotify_credentials)
    spotify_controller.start()

    try:
        inport = mido.open_input()
    except IOError:
        stdscr.addstr(0, 0, "No MIDI input port found. Please connect a MIDI device and restart.")
        stdscr.refresh()
        time.sleep(5)
        return

    stdscr.nodelay(1)
    init_colors()

    scroll_position = 0
    max_y, max_x = stdscr.getmaxyx()

    while True:
        stdscr.clear()
        max_y, max_x = stdscr.getmaxyx()

        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}", curses.color_pair(4))
        stdscr.addstr(1, 0, "Available scenes (sorted by MIDI):")

        visible_range = max_y - 7  # Reduced to make room for Spotify info
        total_scenes = len(scene_manager.scenes)
        
        for i, (scene, data) in enumerate(list(scene_manager.scenes.items())[scroll_position:scroll_position+visible_range]):
            if i >= visible_range:
                break
            midi_note = data.get('midi', 'N/A')
            scene_str = f"{scene} | MIDI Note: {midi_note}"
            if len(scene_str) > max_x:
                scene_str = scene_str[:max_x-3] + "..."
            
            if scene == scene_manager.current_scene['name']:
                stdscr.attron(curses.color_pair(8) | curses.A_BOLD)
                stdscr.addstr(i+3, 0, scene_str)
                stdscr.attroff(curses.color_pair(8) | curses.A_BOLD)
            else:
                stdscr.addstr(i+3, 0, scene_str, curses.color_pair(2))

        if total_scenes > visible_range:
            stdscr.addstr(max_y-4, 0, f"Scroll: {scroll_position+1}-{min(scroll_position+visible_range, total_scenes)}/{total_scenes}")

        # Display Spotify information
        if spotify_controller.spotifizer.playing:
            stdscr.addstr(max_y-3, 0, f"Now playing: {spotify_controller.spotifizer.title} by {spotify_controller.spotifizer.artist}", curses.color_pair(6))
        else:
            stdscr.addstr(max_y-3, 0, "No track playing", curses.color_pair(6))

        stdscr.addstr(max_y-2, 0, "Press 'q' to quit. 'r' to reload. Up/Down to scroll.", curses.color_pair(5))
        stdscr.addstr(max_y-1, 0, "Press 's' to toggle Spotify auto-scene selection.", curses.color_pair(5))
        
        stdscr.refresh()

        for msg in inport.iter_pending():
            if msg.type == 'note_on':
                if msg.note in midi_scene_map:
                    try:
                        light_controller.change_scene(midi_scene_map[msg.note])
                    except Exception as e:
                        stdscr.addstr(max_y-1, 0, f"Error changing scene: {str(e)}")

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            spotify_controller.stop()
            spotify_controller.join()
            break
        elif key == ord('r'):
            scene_manager.reload_scenes()
            scene_manager.scenes = sort_scenes_by_midi(scene_manager.scenes)
            midi_scene_map = create_midi_scene_map(scene_manager.scenes)
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(max_y-1, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)
        elif key == ord('s'):
            spotify_controller.running.set() if not spotify_controller.running.is_set() else spotify_controller.running.clear()
            stdscr.addstr(max_y-1, 0, f"Spotify auto-scene selection: {'ON' if spotify_controller.running.is_set() else 'OFF'}")
            stdscr.refresh()
            time.sleep(1)
        elif key == curses.KEY_UP and scroll_position > 0:
            scroll_position -= 1
        elif key == curses.KEY_DOWN and scroll_position < total_scenes - visible_range:
            scroll_position += 1
        elif key != -1:
            key_char = chr(key) if 0 <= key <= 255 else None
            if key_char in [scene['key_command'] for scene in scene_manager.scenes.values() if 'key_command' in scene]:
                for scene, data in scene_manager.scenes.items():
                    if data.get('key_command') == key_char:
                        light_controller.change_scene(scene)
                        break

        time.sleep(0.01)

    curses.endwin()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    test_imports.py

    Content of test_imports.py:
    ----------------------------------------
from oculizer import AudioListener, LightController, SceneManager, AudioLightController
from oculizer.config import audio_parameters
import time

print("AudioListener imported successfully")
print("LightController imported successfully")
print("SceneManager imported successfully")
print(f"Audio parameters: {audio_parameters}")

# Instantiate AudioListener to ensure it works
listener = AudioListener()
print("AudioListener instantiated successfully")

listener.start()  # Use start() instead of run()
time.sleep(2)
listener.stop()
listener.join()  # Wait for the thread to finish
print('AudioListener started, stopped, and joined successfully')

# Instantiate LightController to ensure it works
controller = LightController(listener, 'testing', SceneManager('scenes'))
print("LightController instantiated successfully")

controller.start()  # Use start() instead of run()
time.sleep(2)
controller.stop()
controller.join()  # Wait for the thread to finish
print('LightController started, stopped, and joined successfully')

# Instantiate SceneManager to ensure it works
manager = SceneManager('scenes')
print("SceneManager instantiated successfully")

print('SceneManager started, stopped, and joined successfully')

print("All imports and instantiations successful")
    ----------------------------------------

    prepare_repo.py

    Content of prepare_repo.py:
    ----------------------------------------
import os

def is_relevant_file(filename):
    relevant_extensions = ('.py', '.json', '.md')
    irrelevant_patterns = ('__pycache__', '.vscode', '.DS_Store', '.gitignore')
    return filename.endswith(relevant_extensions) and not any(pattern in filename for pattern in irrelevant_patterns)

def generate_repo_overview(root_dir):
    overview = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Remove hidden directories and files from the walk
        dirnames[:] = [d for d in dirnames if not d.startswith('.') and 'song_data' not in d]
        filenames = [f for f in filenames if not f.startswith('.') and is_relevant_file(f)]
        
        if not filenames:  # Skip empty directories
            continue
        
        level = dirpath.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        overview.append(f'{indent}{os.path.basename(dirpath)}/')
        sub_indent = ' ' * 4 * (level + 1)
        for f in filenames:
            overview.append(f'{sub_indent}{f}')
            file_path = os.path.join(dirpath, f)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                overview.append(f'\n{sub_indent}Content of {f}:')
                overview.append(f'{sub_indent}' + '-' * 40)
                overview.append(content)
                overview.append(f'{sub_indent}' + '-' * 40 + '\n')
    
    return '\n'.join(overview)

def main():
    root_dir = os.getcwd()  # Get the current working directory
    output_file = 'repo_overview.txt'
    
    repo_overview = generate_repo_overview(root_dir)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(repo_overview)
    
    print(f"Repository overview has been generated and saved to {output_file}")

if __name__ == "__main__":
    main()
    ----------------------------------------

    __init__.py

    Content of __init__.py:
    ----------------------------------------
from .audio.audio_listener import AudioListener
from .light.control import LightController
from .scenes.scene_manager import SceneManager



    ----------------------------------------

    scene_assignment.py

    Content of scene_assignment.py:
    ----------------------------------------
import os
import json
import time
import mido
import curses
from collections import OrderedDict
import random

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer
import spotipy

def load_song_data(song_data_dir):
    song_data = {}
    for filename in os.listdir(song_data_dir):
        if filename.endswith('.json'):
            with open(os.path.join(song_data_dir, filename), 'r') as f:
                song_data[filename[:-5]] = json.load(f)
    return song_data

def save_song_data(song_data, song_data_dir):
    for song_id, data in song_data.items():
        with open(os.path.join(song_data_dir, f"{song_id}.json"), 'w') as f:
            json.dump(data, f, indent=2)

def get_all_sections(song_data):
    for song_id, data in song_data.items():
        for i, section in enumerate(data.get('sections', [])):
            yield song_id, i

def create_midi_scene_map(scenes):
    return {scene_data.get('midi'): scene_name for scene_name, scene_data in scenes.items() if 'midi' in scene_data}

def exponential_backoff(attempt, max_delay=60):
    delay = min(random.uniform(0, 2**attempt), max_delay)
    time.sleep(delay)

def get_all_sections(song_data):
    for song_id, data in song_data.items():
        for i, section in enumerate(data.get('sections', [])):
            yield song_id, i, section.get('scene')

def find_first_unassigned_section(all_sections):
    for index, (song_id, section_index, scene) in enumerate(all_sections):
        if scene is None:
            return index
    return 0  # If all sections are assigned, start from the beginning

def save_song_data(song_data, song_data_dir, current_song_id):
    filepath = os.path.join(song_data_dir, f"{current_song_id}.json")
    with open(filepath, 'w') as f:
        json.dump(song_data[current_song_id], f, indent=2)
    return filepath

def main(stdscr):
    # Initialize components
    scene_manager = SceneManager('scenes')
    scene_manager.scenes = OrderedDict(sorted(scene_manager.scenes.items(), key=lambda x: x[1].get('midi', float('inf'))))
    midi_scene_map = create_midi_scene_map(scene_manager.scenes)
    
    light_controller = Oculizer('garage', scene_manager)
    light_controller.start()

    # Read Spotify credentials
    credspath = os.path.join(os.path.dirname(__file__), 'spotify_credentials.txt')
    with open(credspath) as f:
        lines = f.readlines()
        client_id = lines[0].strip().split(' ')[1]
        client_secret = lines[1].strip().split(' ')[1]
        redirect_uri = lines[2].strip().split(' ')[1]
    
    spotify_controller = Spotifizer(client_id, client_secret, redirect_uri)
    spotify_controller.start()

    # Load song data
    song_data_dir = 'song_data'
    song_data = load_song_data(song_data_dir)
    
    # Set up MIDI input
    try:
        inport = mido.open_input()
    except IOError:
        stdscr.addstr(0, 0, "No MIDI input port found. Please connect a MIDI device and restart.")
        stdscr.refresh()
        time.sleep(5)
        return

    # Set up curses
    curses.curs_set(0)
    stdscr.nodelay(1)

    # Main loop
    all_sections = list(get_all_sections(song_data))
    current_index = find_first_unassigned_section(all_sections)
    max_retries = 5
    section_start_time = None
    local_progress = 0

    while True:
        stdscr.clear()

        if current_index < len(all_sections):
            current_song_id, current_section_index, _ = all_sections[current_index]
            current_song = song_data[current_song_id]
            current_section = current_song['sections'][current_section_index]

            # Display current song and section info
            stdscr.addstr(0, 0, f"Song: {current_song['track']['name']} by {', '.join(current_song['track']['artists'])}")
            stdscr.addstr(1, 0, f"Section: {current_section_index + 1}/{len(current_song['sections'])}")
            stdscr.addstr(2, 0, f"Start: {current_section['start']:.2f}s, Duration: {current_section['duration']:.2f}s")
            stdscr.addstr(3, 0, f"Loudness: {current_section['loudness']:.2f}dB, Tempo: {current_section['tempo']:.2f} BPM")
            stdscr.addstr(4, 0, f"Current scene: {scene_manager.current_scene['name']}")
            stdscr.addstr(5, 0, f"Assigned scene: {current_section.get('scene', 'None')}")

            # Play the current section
            if spotify_controller.current_track_id != current_song_id or section_start_time is None:
                for attempt in range(max_retries):
                    try:
                        spotify_controller.spotify.start_playback(uris=[f"spotify:track:{current_song_id}"])
                        break
                    except spotipy.exceptions.SpotifyException as e:
                        if e.http_status == 429:  # Rate limiting error
                            stdscr.addstr(len(scene_manager.scenes) + 12, 0, f"Rate limit hit. Retrying in a moment...")
                            stdscr.refresh()
                            exponential_backoff(attempt)
                        else:
                            raise
                else:
                    stdscr.addstr(len(scene_manager.scenes) + 12, 0, f"Failed to start playback after {max_retries} attempts.")
                    stdscr.refresh()
                    time.sleep(2)
                    continue

                time.sleep(0.5)  # Wait for playback to start
                section_start = current_section['start'] * 1000  # Convert to milliseconds
                spotify_controller.seek_to_timestamp(int(section_start))
                section_start_time = time.time()
                local_progress = 0

            # Update local progress
            if section_start_time is not None:
                local_progress = (time.time() - section_start_time) * 1000  # in milliseconds

            # Display progress
            section_duration = current_section['duration'] * 1000  # in milliseconds
            progress_percent = min(100, (local_progress / section_duration) * 100)
            stdscr.addstr(6, 0, f"Progress: {progress_percent:.1f}%")

            # Loop the current section
            if local_progress >= section_duration:
                section_start_time = time.time()
                local_progress = 0
                spotify_controller.seek_to_timestamp(int(current_section['start'] * 1000))

            # Display available scenes
            stdscr.addstr(8, 0, "Available scenes:")
            for i, (scene_name, scene_data) in enumerate(scene_manager.scenes.items()):
                midi_note = scene_data.get('midi', 'N/A')
                stdscr.addstr(i+9, 0, f"{scene_name} | MIDI Note: {midi_note}")

            stdscr.addstr(len(scene_manager.scenes) + 10, 0, "Press Enter to assign current scene, <- -> to navigate sections")
            stdscr.addstr(len(scene_manager.scenes) + 11, 0, "Press 'r' to reload scenes, 'q' to quit")

        else:
            stdscr.addstr(0, 0, "No sections found in song data.")
            stdscr.addstr(1, 0, "Press 'q' to quit.")

        # Handle user input
        key = stdscr.getch()
        if key == ord('\n'):  # Enter key
            current_section['scene'] = scene_manager.current_scene['name']
            all_sections[current_index] = (current_song_id, current_section_index, current_section['scene'])
            
            # Save the updated data immediately
            saved_file = save_song_data(song_data, song_data_dir, current_song_id)
            
            stdscr.addstr(len(scene_manager.scenes) + 12, 0, f"Scene {scene_manager.current_scene['name']} assigned to section {current_section_index + 1}/{len(current_song['sections'])}")
            stdscr.addstr(len(scene_manager.scenes) + 13, 0, f"Data saved to {saved_file}")
            stdscr.refresh()
            time.sleep(1)
        elif key == curses.KEY_RIGHT:
            current_index = (current_index + 1) % len(all_sections)
            section_start_time = None  # Reset timer for new section
        elif key == curses.KEY_LEFT:
            current_index = (current_index - 1) % len(all_sections)
            section_start_time = None  # Reset timer for new section
        elif key == ord('r'):
            scene_manager.reload_scenes()
            scene_manager.scenes = OrderedDict(sorted(scene_manager.scenes.items(), key=lambda x: x[1].get('midi', float('inf'))))
            midi_scene_map = create_midi_scene_map(scene_manager.scenes)
            light_controller.scene_manager = scene_manager  # Update the light controller with the new scenes
            stdscr.addstr(len(scene_manager.scenes) + 12, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)
        elif key == ord('q'):
            stdscr.addstr(len(scene_manager.scenes) + 12, 0, "Quitting and saving data...")
            stdscr.refresh()
            break

        # Handle MIDI input
        for msg in inport.iter_pending():
            if msg.type == 'note_on' and msg.note in midi_scene_map:
                scene_name = midi_scene_map[msg.note]
                light_controller.change_scene(scene_name)

        stdscr.refresh()
        time.sleep(0.01)

    # Clean up
    light_controller.stop()
    light_controller.join()
    spotify_controller.stop()
    spotify_controller.join()
    save_song_data(song_data, song_data_dir)

if __name__ == "__main__":
    curses.wrapper(main)

    ----------------------------------------

    run_dev.py

    Content of run_dev.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
from PyQt5.QtCore import QTimer
import pyqtgraph as pg

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager
from oculizer.config import audio_parameters

nmfft = audio_parameters['NMFFT']

class MFFTVisualizer(QMainWindow):
    def __init__(self, light_controller):
        super().__init__()
        self.setWindowTitle("MFFT Visualizer")
        self.setGeometry(100, 100, 800, 400)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.mfft_plot = pg.PlotWidget(title='Mel-scaled FFT')
        layout.addWidget(self.mfft_plot)

        self.mfft_bars = pg.BarGraphItem(x=range(nmfft), height=[0]*nmfft, width=0.8, brush='b')
        self.mfft_plot.addItem(self.mfft_bars)

        self.mfft_plot.setLabel('left', 'Magnitude')
        self.mfft_plot.setLabel('bottom', 'MFFT Coefficient')
        self.mfft_plot.showGrid(y=True)
        self.mfft_plot.setYRange(0, 20)
        self.mfft_plot.setXRange(-0.5, nmfft+0.5)

        self.light_controller = light_controller

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(10)  # Update every 10 ms

    def update_plot(self):
        try:
            mfft = self.light_controller.mfft_queue.get(block=False)
            if mfft is not None and len(mfft) == nmfft:
                self.mfft_bars.setOpts(height=mfft)
        except queue.Empty:
            pass

def curses_thread(stdscr, scene_manager, light_controller):
    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")

        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")
        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('blue')
    light_controller = Oculizer('garage', scene_manager)

    light_controller.start()

    app = QApplication(sys.argv)
    visualizer = MFFTVisualizer(light_controller)
    visualizer.show()

    curses_thread_obj = threading.Thread(target=curses_thread, args=(stdscr, scene_manager, light_controller))
    curses_thread_obj.start()

    app.exec_()

    light_controller.stop()
    light_controller.join()
    curses_thread_obj.join()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    README.md

    Content of README.md:
    ----------------------------------------
```    
          ___           ___           ___           ___                   ___           ___           ___     
         /\  \         /\  \         /\__\         /\__\      ___        /\  \         /\  \         /\  \    
        /::\  \       /::\  \       /:/  /        /:/  /     /\  \       \:\  \       /::\  \       /::\  \   
       /:/\:\  \     /:/\:\  \     /:/  /        /:/  /      \:\  \       \:\  \     /:/\:\  \     /:/\:\  \  
      /:/  \:\  \   /:/  \:\  \   /:/  /  ___   /:/  /       /::\__\       \:\  \   /::\~\:\  \   /::\~\:\  \ 
     /:/__/ \:\__\ /:/__/ \:\__\ /:/__/  /\__\ /:/__/     __/:/\/__/ _______\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ 
     \:\  \ /:/  / \:\  \  \/__/ \:\  \ /:/  / \:\  \    /\/:/  /    \::::::::/__/ \:\~\:\ \/__/ \/_|::\/:/  /
      \:\  /:/  /   \:\  \        \:\  /:/  /   \:\  \   \::/__/      \:\~~\~~      \:\ \:\__\      |:|::/  / 
       \:\/:/  /     \:\  \        \:\/:/  /     \:\  \   \:\__\       \:\  \        \:\ \/__/      |:|\/__/  
        \::/  /       \:\__\        \::/  /       \:\__\   \/__/        \:\__\        \:\__\        |:|  |    
         \/__/         \/__/         \/__/         \/__/                 \/__/         \/__/         \|__|    


```

Intelligent, real-time audio-reactive DMX lighting. 

In active development. 

    ----------------------------------------

    run_midi.py

    Content of run_midi.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import mido
from collections import OrderedDict

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager

def create_midi_scene_map(scenes):
    midi_scene_map = {}
    for scene_name, scene_data in scenes.items():
        if 'midi' in scene_data:
            midi_scene_map[scene_data['midi']] = scene_name
    return midi_scene_map

def sort_scenes_by_midi(scenes):
    scene_list = [(data.get('midi', float('inf')), name, data) for name, data in scenes.items()]
    sorted_scenes = sorted(scene_list, key=lambda x: x[0])
    return OrderedDict((name, data) for _, name, data in sorted_scenes)

def init_colors():
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_BLUE, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)
    curses.init_pair(6, curses.COLOR_CYAN, -1)
    curses.init_pair(7, curses.COLOR_WHITE, -1)
    curses.init_pair(8, curses.COLOR_BLACK, curses.COLOR_WHITE)  # For highlighting

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('party')  # Set an initial scene
    light_controller = Oculizer('garage', scene_manager)

    scene_manager.scenes = sort_scenes_by_midi(scene_manager.scenes)
    midi_scene_map = create_midi_scene_map(scene_manager.scenes)

    light_controller.start()

    try:
        inport = mido.open_input()
    except IOError:
        stdscr.addstr(0, 0, "No MIDI input port found. Please connect a MIDI device and restart.")
        stdscr.refresh()
        time.sleep(5)
        return

    stdscr.nodelay(1)
    init_colors()

    scroll_position = 0
    max_y, max_x = stdscr.getmaxyx()

    while True:
        stdscr.clear()
        max_y, max_x = stdscr.getmaxyx()

        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}", curses.color_pair(4))
        stdscr.addstr(1, 0, "Available scenes (sorted by MIDI):")

        visible_range = max_y - 5
        total_scenes = len(scene_manager.scenes)
        
        for i, (scene, data) in enumerate(list(scene_manager.scenes.items())[scroll_position:scroll_position+visible_range]):
            if i >= visible_range:
                break
            midi_note = data.get('midi', 'N/A')
            scene_str = f"{scene} | MIDI Note: {midi_note}"
            if len(scene_str) > max_x:
                scene_str = scene_str[:max_x-3] + "..."
            
            if scene == scene_manager.current_scene['name']:
                stdscr.attron(curses.color_pair(8) | curses.A_BOLD)
                stdscr.addstr(i+3, 0, scene_str)
                stdscr.attroff(curses.color_pair(8) | curses.A_BOLD)
            else:
                stdscr.addstr(i+3, 0, scene_str, curses.color_pair(2))

        if total_scenes > visible_range:
            stdscr.addstr(max_y-2, 0, f"Scroll: {scroll_position+1}-{min(scroll_position+visible_range, total_scenes)}/{total_scenes}")
        stdscr.addstr(max_y-1, 0, "Press 'q' to quit. 'r' to reload. Up/Down to scroll.", curses.color_pair(5))
        
        stdscr.refresh()

        for msg in inport.iter_pending():
            if msg.type == 'note_on':
                if msg.note in midi_scene_map:
                    try:
                        light_controller.change_scene(midi_scene_map[msg.note])
                    except Exception as e:
                        stdscr.addstr(max_y-1, 0, f"Error changing scene: {str(e)}")

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key == ord('r'):
            scene_manager.reload_scenes()
            scene_manager.scenes = sort_scenes_by_midi(scene_manager.scenes)
            midi_scene_map = create_midi_scene_map(scene_manager.scenes)
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(max_y-1, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)
        elif key == curses.KEY_UP and scroll_position > 0:
            scroll_position -= 1
        elif key == curses.KEY_DOWN and scroll_position < total_scenes - visible_range:
            scroll_position += 1
        elif key != -1:
            key_char = chr(key) if 0 <= key <= 255 else None
            if key_char in [scene['key_command'] for scene in scene_manager.scenes.values() if 'key_command' in scene]:
                for scene, data in scene_manager.scenes.items():
                    if data.get('key_command') == key_char:
                        light_controller.change_scene(scene)
                        break

        time.sleep(0.01)

    curses.endwin()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    setup.py

    Content of setup.py:
    ----------------------------------------
from setuptools import setup, find_packages

setup(
    name="oculizer",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        # List your dependencies here
        'numpy',
        'scipy',
        'sounddevice',
        'librosa',
        'pydub',
        'scipy', 
        'sounddevice',
        'soundfile',
        'sklearn',
        'PyDMXControl'
    ],
)
    ----------------------------------------

    run_the_oculizer.py

    Content of run_the_oculizer.py:
    ----------------------------------------
import os
import json
import time
import threading
import curses
from curses import wrapper
from oculizer import Oculizer, SceneManager
from oculizer.spotify import Spotifizer
import logging
from collections import deque

# ASCII art for Oculizer
OCULIZER_ASCII = """
   ____            _ _              
  / __ \          | (_)             
 | |  | | ___ _   | |_ _______ _ __ 
  | |  | |/ __| | | | | |_  / _ \ '__|
  | |__| | (__| |_| | | |/ /  __/ |   
   \____/ \___|\__,_|_|_/___\___|_|   
"""

# set up curses color pairs
COLOR_PAIRS = {
    'title': (curses.COLOR_CYAN, curses.COLOR_BLACK),
    'info': (curses.COLOR_GREEN, curses.COLOR_BLACK),
    'error': (curses.COLOR_RED, curses.COLOR_BLACK),
    'warning': (curses.COLOR_YELLOW, curses.COLOR_BLACK),
    'ascii_art': (curses.COLOR_MAGENTA, curses.COLOR_BLACK),
    'log': (curses.COLOR_WHITE, curses.COLOR_BLACK),
    'controls': (curses.COLOR_BLUE, curses.COLOR_BLACK),
}

def setup_colors():
    curses.start_color()
    for i, (name, (fg, bg)) in enumerate(COLOR_PAIRS.items(), start=1):
        curses.init_pair(i, fg, bg)
        COLOR_PAIRS[name] = i

class WatchdogTimer:
    def __init__(self, timeout, callback):
        self.timeout = timeout
        self.callback = callback
        self.timer = threading.Timer(self.timeout, self.handle_timeout)
        self.last_reset = time.time()

    def reset(self):
        self.timer.cancel()
        self.last_reset = time.time()
        self.timer = threading.Timer(self.timeout, self.handle_timeout)
        self.timer.start()

    def handle_timeout(self):
        if time.time() - self.last_reset >= self.timeout:
            self.callback()

    def stop(self):
        self.timer.cancel()

class SpotifyOculizerController:
    def __init__(self, client_id, client_secret, redirect_uri, stdscr):
        self.stdscr = stdscr
        curses.curs_set(0)
        self.stdscr.nodelay(1)
        
        self.scene_manager = SceneManager('scenes')
        self.oculizer = Oculizer('garage', self.scene_manager)
        self.client_id = client_id
        self.client_secret = client_secret
        self.redirect_uri = redirect_uri
        self.spotifizer = self.create_spotifizer()
        self.song_data_dir = 'song_data'
        self.current_song_id = None
        self.current_song_data = None
        self.current_section_index = None
        self.error_message = ""
        self.info_message = ""
        self.watchdog = WatchdogTimer(10, self.reinitialize)  # 10-second timeout
        self.reinitialize_flag = threading.Event()
        
        # Set up logging
        self.log_messages = deque(maxlen=50)
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.log_handler = self.LogHandler(self.log_messages)
        logging.getLogger().addHandler(self.log_handler)

    class LogHandler(logging.Handler):
        def __init__(self, log_messages):
            super().__init__()
            self.log_messages = log_messages

        def emit(self, record):
            log_entry = self.format(record)
            self.log_messages.append(log_entry)

    def start(self):
        try:
            self.oculizer.start()
            self.spotifizer.start()
            self.watchdog.reset()
            self.run()
        except Exception as e:
            self.error_message = f"Error starting controller: {str(e)}"
            logging.error(f"Error starting controller: {str(e)}")

    def run(self):
        update_thread = threading.Thread(target=self.update_loop)
        update_thread.daemon = True
        update_thread.start()

        while True:
            if self.reinitialize_flag.is_set():
                self.perform_reinitialization()
            self.handle_user_input()
            self.update_display()
            self.watchdog.reset()  # Reset the watchdog timer
            time.sleep(0.05)

    def create_spotifizer(self):
        return Spotifizer(self.client_id, self.client_secret, self.redirect_uri)

    def refresh_spotify_token(self):
        try:
            self.spotifizer.stop()
            self.spotifizer = self.create_spotifizer()
            self.spotifizer.start()
            logging.info("Spotify token refreshed successfully")
        except Exception as e:
            logging.error(f"Error refreshing Spotify token: {str(e)}")

    def update_loop(self):
        while True:
            try:
                if self.spotifizer.playing:
                    song_changed = self.check_and_update_song()
                    self.update_current_section()
                    self.update_lighting(force_update=song_changed)
                else:
                    self.scene_manager.set_scene('off')
            except spotipy.SpotifyException as e:
                if e.http_status == 401 and 'The access token expired' in str(e):
                    logging.warning("Spotify access token expired. Refreshing...")
                    self.refresh_spotify_token()
                else:
                    self.error_message = f"Spotify API error: {str(e)}"
                    logging.error(f"Spotify API error: {str(e)}")
            except Exception as e:
                self.error_message = f"Error in update loop: {str(e)}"
                logging.error(f"Error in update loop: {str(e)}")
            time.sleep(0.1)

    def reinitialize(self):
        logging.warning("Watchdog detected a freeze. Triggering reinitialization.")
        self.reinitialize_flag.set()

    def perform_reinitialization(self):
        logging.info("Performing reinitialization...")
        self.stop()
        time.sleep(1)  # Allow time for threads to stop

        # Reinitialize components
        self.scene_manager = SceneManager('scenes')
        self.oculizer = Oculizer('garage', self.scene_manager)
        self.spotifizer = self.create_spotifizer()

        # Restart components
        self.oculizer.start()
        self.spotifizer.start()

        self.reinitialize_flag.clear()
        self.watchdog.reset()
        logging.info("Reinitialization complete.")

    def check_and_update_song(self):
        if self.spotifizer.current_track_id != self.current_song_id:
            self.current_song_id = self.spotifizer.current_track_id
            self.current_song_data = self.load_song_data(self.current_song_id)
            self.current_section_index = None  # Reset section index
            self.info_message = f"Now playing: {self.spotifizer.title} by {self.spotifizer.artist}"
            logging.info(f"Now playing: {self.spotifizer.title} by {self.spotifizer.artist}")
            return True
        return False

    def update_current_section(self):
        if self.current_song_data is None:
            return

        current_time = self.spotifizer.progress / 1000
        sections = self.current_song_data.get('sections', [])

        new_section_index = next((i for i, section in enumerate(sections) if section['start'] <= current_time < (section['start'] + section['duration'])), None)
        time.sleep(0.1)

        if new_section_index != self.current_section_index:
            self.current_section_index = new_section_index
            logging.info(f"Updated to section index: {self.current_section_index}")

    def load_song_data(self, song_id):
        try:
            filename = os.path.join(self.song_data_dir, f"{song_id}.json")
            if os.path.exists(filename):
                with open(filename, 'r') as f:
                    return json.load(f)
            else:
                self.info_message = f"Song data not found for {song_id}. Using default scene."
                logging.warning(f"Song data not found for {song_id}. Using default scene.")
                return None
        except Exception as e:
            self.error_message = f"Error loading song data: {str(e)}"
            logging.error(f"Error loading song data: {str(e)}")
            return None

    def turn_off_all_lights(self):
        try:
            for light_name, light_fixture in self.oculizer.controller_dict.items():
                if hasattr(light_fixture, 'dim'):
                    light_fixture.dim(0)
                elif hasattr(light_fixture, 'set_channels'):
                    light_fixture.set_channels([0] * light_fixture.channels)
            self.oculizer.dmx_controller.update()       # this is a magic piece of code that is broken, but it saves the day somehow
            logging.info("All lights turned off")
        except Exception as e:
            if not 'OpenDMXController' in str(e):
                self.error_message = f"Error turning off lights: {str(e)}"
                logging.error(f"Error turning off lights: {str(e)}")

    def update_lighting(self, force_update=False):
        try:
            if self.current_song_data is None:
                self.turn_off_all_lights()
                self.scene_manager.set_scene('chill_pink')
                self.info_message = "No song data found. Using default scene."
                logging.info("No song data found. Using default scene.")
                return

            sections = self.current_song_data.get('sections', [])

            if not sections:
                self.turn_off_all_lights()
                self.scene_manager.set_scene('off')
                self.info_message = "No sections found in song data. Using default scene."
                logging.warning("No sections found in song data. Using default scene.")
                return

            if self.current_section_index is not None:
                current_section = sections[self.current_section_index]
                scene = current_section.get('scene', 'off')
                
                if scene != self.scene_manager.current_scene['name'] or force_update:
                    self.info_message = f"Changing to scene: {scene}"
                    logging.info(f"Changing to scene: {scene}")
                    self.turn_off_all_lights()
                    self.scene_manager.set_scene(scene)
            else:
                logging.warning(f"Current section index is None.")
        except Exception as e:
            self.error_message = f"Error updating lighting: {str(e)}"
            logging.error(f"Error updating lighting: {str(e)}")

    def handle_user_input(self):
        try:
            key = self.stdscr.getch()
            if key == ord('q'):
                self.stop()
                exit()
            elif key == ord('r'):
                self.scene_manager.reload_scenes()
                self.info_message = "Scenes reloaded"
                logging.info("Scenes reloaded")
        except Exception as e:
            self.error_message = f"Error handling user input: {str(e)}"
            logging.error(f"Error handling user input: {str(e)}")

    def update_display(self):
        try:
            self.stdscr.clear()
            height, width = self.stdscr.getmaxyx()

            # Display title
            title = "Spotify Oculizer Controller"
            self.stdscr.addstr(0, (width - len(title)) // 2, title, curses.color_pair(COLOR_PAIRS['title']) | curses.A_BOLD)

            # Display current song and progress
            if self.spotifizer.playing:
                song_info = f"Now playing: {self.spotifizer.title} by {self.spotifizer.artist}"
                self.stdscr.addstr(2, 0, song_info[:width-1], curses.color_pair(COLOR_PAIRS['info']))
                progress = f"Progress: {self.spotifizer.progress / 1000:.2f}s"
                self.stdscr.addstr(3, 0, progress, curses.color_pair(COLOR_PAIRS['info']))
            else:
                self.stdscr.addstr(2, 0, "No song playing", curses.color_pair(COLOR_PAIRS['warning']))

            # Display current scene
            scene_info = f"Current scene: {self.scene_manager.current_scene['name']}"
            self.stdscr.addstr(5, 0, scene_info[:width-1], curses.color_pair(COLOR_PAIRS['info']))

            # Display ASCII art
            ascii_lines = OCULIZER_ASCII.split('\n')
            start_row = (height - len(ascii_lines)) // 2
            for i, line in enumerate(ascii_lines):
                self.stdscr.addstr(start_row + i, (width - len(line)) // 2, line, curses.color_pair(COLOR_PAIRS['ascii_art']))

            # Display log messages
            log_start = height - len(self.log_messages) - 2
            self.stdscr.addstr(log_start - 1, 0, "Log Messages:", curses.color_pair(COLOR_PAIRS['log']) | curses.A_BOLD)
            for i, message in enumerate(self.log_messages):
                self.stdscr.addstr(log_start + i, 0, message[:width-1], curses.color_pair(COLOR_PAIRS['log']))

            # Display info message
            if self.info_message:
                self.stdscr.addstr(height-3, 0, self.info_message[:width-1], curses.color_pair(COLOR_PAIRS['info']) | curses.A_BOLD)

            # Display error message
            if self.error_message:
                self.stdscr.addstr(height-2, 0, self.error_message[:width-1], curses.color_pair(COLOR_PAIRS['error']))

            # Display controls
            controls = "Press 'q' to quit, 'r' to reload scenes"
            self.stdscr.addstr(height-1, 0, controls[:width-1], curses.color_pair(COLOR_PAIRS['controls']))

            self.stdscr.refresh()
        except Exception as e:
            import sys
            print(f"Error updating display: {str(e)}", file=sys.stderr)
            logging.error(f"Error updating display: {str(e)}")

    def stop(self):
        try:
            self.oculizer.stop()
            self.spotifizer.stop()
            self.oculizer.join()
            self.spotifizer.join()
            self.watchdog.stop()
            logging.info("Spotify Oculizer Controller stopped")
        except Exception as e:
            self.error_message = f"Error stopping controller: {str(e)}"
            logging.error(f"Error stopping controller: {str(e)}")

def main(stdscr):
    setup_colors()

    try:
        credspath = os.path.join(os.path.dirname(__file__), 'spotify_credentials.txt')
        with open(credspath) as f:
            lines = f.readlines()
            client_id = lines[0].strip().split(' ')[1]
            client_secret = lines[1].strip().split(' ')[1]
            redirect_uri = lines[2].strip().split(' ')[1]
    except Exception as e:
        stdscr.addstr(0, 0, f"Error reading Spotify credentials: {str(e)}", curses.color_pair(1))
        stdscr.refresh()
        time.sleep(5)
        return

    controller = SpotifyOculizerController(client_id, client_secret, redirect_uri, stdscr)
    
    try:
        controller.start()
    except KeyboardInterrupt:
        controller.stop()
    except Exception as e:
        stdscr.addstr(0, 0, f"Unhandled error: {str(e)}", curses.color_pair(COLOR_PAIRS['error']))
        stdscr.refresh()
        time.sleep(5)

if __name__ == "__main__":
    wrapper(main)
    ----------------------------------------

    reformat_scenes.py

    Content of reformat_scenes.py:
    ----------------------------------------
import json
import os
from collections import OrderedDict

def custom_key_order(key):
    # Define the desired order of keys
    order = ['name', 'description', 'type', 'midi', 'key_command', 'lights']
    
    # Return the index of the key if it's in the order list, otherwise return a high number
    return order.index(key) if key in order else len(order)

def order_dict(item):
    if isinstance(item, dict):
        
        return OrderedDict(sorted(item.items(), key=lambda x: custom_key_order(x[0])))
    elif isinstance(item, list):
        return [order_dict(i) for i in item]
    return item

scene_dir = 'scenes'
scenes = []

# Load the scenes
for scene_file in os.listdir(scene_dir):
    if scene_file.endswith('.json'):
        with open(os.path.join(scene_dir, scene_file)) as f:
            scenes.append(json.load(f))

# Add type to scenes (if not already done) and order the dictionaries
ordered_scenes = []
for scene in scenes:
    name = scene['name']
    if 'type' not in scene:
        if 'build' in name:
            scene['type'] = 'build'
        elif 'drop' in name:
            scene['type'] = 'drop'
        elif 'ambient' in name:
            scene['type'] = 'ambient'
        else:
            scene['type'] = 'effect'
    
    # Order the scene dictionary and its nested structures
    ordered_scenes.append(order_dict(scene))

# Custom JSON encoder to handle OrderedDict
class OrderedDictEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, OrderedDict):
            return {k: self.default(v) for k, v in obj.items()}
        return super().default(obj)

# Save scenes back to JSON files with improved formatting and custom order
for scene in ordered_scenes:
    filename = os.path.join(scene_dir, scene['name'] + '.json')
    with open(filename, 'w') as f:
        json.dump(scene, f, indent=2, cls=OrderedDictEncoder)

print("All scene files have been updated with improved formatting and custom key order.")

    ----------------------------------------

    run_printer.py

    Content of run_printer.py:
    ----------------------------------------
import mido
import time

def print_midi_notes():
    print("MIDI Note Printer")
    print("=================")
    print("Press keys on your MIDI keyboard to see their note numbers.")
    print("Press Ctrl+C to exit.")
    print()

    try:
        with mido.open_input() as inport:
            print(f"Listening on MIDI input: {inport.name}")
            print()
            
            while True:
                for msg in inport.iter_pending():
                    if msg.type == 'note_on':
                        note_name = msg.note
                        print(f" Number: {msg.note:3d}") # Name: {note_name:>3}, Velocity: {msg.velocity:3d}")
                    # elif msg.type == 'note_off':
                    #     note_name = msg.note
                    #     print(f"Note Off - Number: {msg.note:3d}, Name: {note_name:>3}, Velocity: {msg.velocity:3d}")
                time.sleep(0.01)  # Short sleep to prevent CPU hogging
                
    except KeyboardInterrupt:
        print("\nExiting...")

if __name__ == "__main__":
    print_midi_notes()
    ----------------------------------------

    run_tester.py

    Content of run_tester.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('hell')
    light_controller = Oculizer('testing', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    scenes/
        build4.json

        Content of build4.json:
        ----------------------------------------
{"name": "build4", "description": "Gradually intensifying scene for track buildups", "type": "build", "midi": 50, "key_command": "b", "lights": [{"name": "ropes", "type": "dimmer", "modulator": "time", "function": "sine", "frequency": 1, "min_brightness": 0, "max_brightness": 90}, {"name": "orb", "type": "dimmer", "modulator": "time", "function": "sine", "frequency": 1, "min_brightness": 0, "max_brightness": 100}]}
        ----------------------------------------

        pink_bass_pulse.json

        Content of pink_bass_pulse.json:
        ----------------------------------------
{"name": "pink_bass_pulse", "description": "All RGBs pulsing pink with bass, high-frequency reactive strobe", "key_command": "r", "midi": 58, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "pink", "strobe": 255}, {"name": "strobe", "type": "strobe", "modulator": "mfft", "threshold": 0.05, "brightness": 255, "mfft_range": [115, 127], "power_range": [1, 4], "speed": 1}]}
        ----------------------------------------

        white_bass_pulse.json

        Content of white_bass_pulse.json:
        ----------------------------------------
{"name": "white_bass_pulse", "description": "All RGBs pulsing white with bass, high-frequency reactive strobe", "key_command": "r", "midi": 57, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "white", "strobe": 255}, {"name": "strobe", "type": "strobe", "modulator": "mfft", "threshold": 0.05, "brightness": 255, "mfft_range": [115, 127], "power_range": [1, 4], "speed": 1}]}
        ----------------------------------------

        suave.json

        Content of suave.json:
        ----------------------------------------
{"name": "suave", "description": "Static ambient lighting with orb and ropes at 100 brightness", "type": "ambient", "midi": 70, "key_command": "o", "lights": [{"name": "orb", "type": "dimmer", "modulator": "bool", "brightness": 70}]}
        ----------------------------------------

        red_bass_pulse.json

        Content of red_bass_pulse.json:
        ----------------------------------------
{"name": "red_bass_pulse", "description": "All RGBs pulsing red with bass, high-frequency reactive strobe", "key_command": "r", "midi": 53, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "strobe", "type": "strobe", "modulator": "mfft", "threshold": 0.05, "brightness": 255, "mfft_range": [115, 127], "power_range": [1, 4], "speed": 1}]}
        ----------------------------------------

        chill_blue.json

        Content of chill_blue.json:
        ----------------------------------------
{"name": "chill_blue", "description": "All RGB lights set to blue, subtly reactive to music", "type": "effect", "midi": 37, "key_command": "p", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "color": "blue", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}]}
        ----------------------------------------

        blue_bass_pulse.json

        Content of blue_bass_pulse.json:
        ----------------------------------------
{"name": "blue_bass_pulse", "description": "All RGBs pulsing blue with bass, high-frequency reactive strobe", "key_command": "r", "midi": 52, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "strobe", "type": "strobe", "modulator": "mfft", "threshold": 0.05, "brightness": 255, "mfft_range": [115, 127], "power_range": [1, 4], "speed": 1}]}
        ----------------------------------------

        rightround.json

        Content of rightround.json:
        ----------------------------------------
{"name": "rightround", "description": "You spin me round! Now with lasers and disco ball.", "type": "effect", "midi": 61, "key_command": "3", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "lasers", "type": "dimmer", "modulator": "bool", "brightness": "random"}, {"name": "discoball", "type": "dimmer", "modulator": "bool", "brightness": 255}]}
        ----------------------------------------

        ambient2.json

        Content of ambient2.json:
        ----------------------------------------
{"name": "ambient2", "description": "Subtle, flowing colors for calmer moments", "type": "ambient", "midi": 41, "key_command": "a", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.1, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.08, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.12, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.09, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.11, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.07, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.13, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.06, "min_brightness": 0, "max_brightness": 100, "color": "red"}, {"name": "ropes", "type": "dimmer", "modulator": "time", "function": 0, "frequency": 0.175, "min_brightness": 0, "max_brightness": 75}, {"name": "orb", "type": "dimmer", "modulator": "time", "function": 0, "frequency": 0.25, "min_brightness": 0, "max_brightness": 100}]}
        ----------------------------------------

        flicker.json

        Content of flicker.json:
        ----------------------------------------
{"name": "flicker", "description": "flicker vintage", "type": "effect", "midi": 84, "key_command": "v", "lights": [{"name": "ropes", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 40, "max_brightness": 70}, {"name": "orb", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 50, "max_brightness": 100}]}
        ----------------------------------------

        temple.json

        Content of temple.json:
        ----------------------------------------
{"name": "temple", "description": "All RGBs pulsing red, reactive to low frequencies, strobe", "key_command": "p", "midi": 78, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 255}]}
        ----------------------------------------

        green_bass_pulse.json

        Content of green_bass_pulse.json:
        ----------------------------------------
{"name": "green_bass_pulse", "description": "All RGBs pulsing green with bass, high-frequency reactive strobe", "key_command": "r", "midi": 55, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0.5, 3.5], "brightness_range": [0, 255], "color": "green", "strobe": 255}, {"name": "strobe", "type": "strobe", "modulator": "mfft", "threshold": 0.05, "brightness": 255, "mfft_range": [115, 127], "power_range": [1, 4], "speed": 1}]}
        ----------------------------------------

        wobble.json

        Content of wobble.json:
        ----------------------------------------
{"name": "wobble", "description": "All RGBs pulsing green, reactive to low frequencies", "key_command": "p", "midi": 66, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [5, 255], "color": "green", "strobe": 0}]}
        ----------------------------------------

        brainblaster.json

        Content of brainblaster.json:
        ----------------------------------------
{"name": "brainblaster", "description": "Bass-reactive rainbow strobes. All else off.", "type": "effect", "midi": 67, "key_command": "3", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 2], "brightness_range": [0, 255], "color": "random", "strobe": 255}]}
        ----------------------------------------

        prance.json

        Content of prance.json:
        ----------------------------------------
{
    "name": "prance",
    "description": "All RGBs pulsing blue with bass, high-frequency reactive strobe",
    "key_command": "r",
    "midi": 56,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3.5],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3.5],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [0, 20],
            "power_range": [0.5, 3.5],
            "brightness_range": [20, 255],
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "mfft",
            "brightness_range": [0, 255],
            "mfft_range": [100, 127],
            "power_range": [0, 0.05]
        }
    ]
}
        ----------------------------------------

        white_riser.json

        Content of white_riser.json:
        ----------------------------------------
{"name": "white_riser", "description": "white riser strobe", "type": "build", "midi": 48, "key_command": "b", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}]}
        ----------------------------------------

        ambient3.json

        Content of ambient3.json:
        ----------------------------------------
{"name": "ambient3", "description": "Subtle, flowing colors for calmer moments", "type": "ambient", "midi": 40, "key_command": "a", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.1, "min_brightness": 0, "max_brightness": 100, "color": "green"}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.08, "min_brightness": 0, "max_brightness": 100, "color": "orange"}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.12, "min_brightness": 0, "max_brightness": 100, "color": "green"}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.09, "min_brightness": 0, "max_brightness": 100, "color": "orange"}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.11, "min_brightness": 0, "max_brightness": 100, "color": "green"}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.07, "min_brightness": 0, "max_brightness": 100, "color": "orange"}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.13, "min_brightness": 0, "max_brightness": 100, "color": "green"}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.06, "min_brightness": 0, "max_brightness": 100, "color": "orange"}, {"name": "ropes", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 40, "max_brightness": 70}, {"name": "orb", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 50, "max_brightness": 100}]}
        ----------------------------------------

        bloop.json

        Content of bloop.json:
        ----------------------------------------
{"name": "bloop", "description": "Stochastic blue strobe on all RGBs. All else off.", "type": "effect", "midi": 62, "key_command": "f", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": "random", "max_brightness": 255, "color": "blue", "strobe": "random"}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "blue", "strobe": "random"}]}
        ----------------------------------------

        bluevelvet.json

        Content of bluevelvet.json:
        ----------------------------------------
{"name": "bluevelvet", "description": "Vintage + blue", "type": "effect", "midi": 71, "key_command": "v", "lights": [{"name": "ropes", "type": "dimmer", "modulator": "mfft", "mfft_range": [0, 50], "brightness_range": [50, 200], "power_range": [0, 5]}, {"name": "orb", "type": "dimmer", "modulator": "mfft", "mfft_range": [50, 128], "brightness_range": [60, 255], "power_range": [0, 0.3]}, {"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 10], "brightness_range": [10, 60], "color": "blue", "strobe": 0}]}
        ----------------------------------------

        sexy.json

        Content of sexy.json:
        ----------------------------------------
{"name": "sexy", "description": "A sultry red ambiance with a reactive orb", "type": "effect", "midi": 63, "key_command": "x", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "color": "red", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [30, 175], "strobe": 0}, {"name": "orb", "type": "dimmer", "modulator": "mfft", "mfft_range": [0, 128], "power_range": [0, 1], "brightness_range": [20, 255]}]}
        ----------------------------------------

        pink_pulse.json

        Content of pink_pulse.json:
        ----------------------------------------
{"name": "pink_pulse", "description": "All RGBs pulsing pink, reactive to low frequencies", "key_command": "p", "midi": 44, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "pink", "strobe": 0}]}
        ----------------------------------------

        off.json

        Content of off.json:
        ----------------------------------------
{
    "name": "off",
    "description": "All lights off",
    "type": "effect",
    "midi": 36,
    "key_command": "o",
    "lights": [
      {
        "name": "rgb1",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb2",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb3",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb4",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb5",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb6",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb7",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "rgb8",
        "type": "rgb",
        "modulator": "bool",
        "brightness": 0,
        "color": "black",
        "strobe": 0
      },
      {
        "name": "lasers",
        "type": "dimmer",
        "modulator": "bool",
        "brightness": 0
      },
      {
        "name": "orb",
        "type": "dimmer",
        "modulator": "bool",
        "brightness": 0
      },
      {
        "name": "discoball",
        "type": "dimmer",
        "modulator": "bool",
        "brightness": 0
      },
      {
        "name": "ropes",
        "type": "dimmer",
        "modulator": "bool",
        "brightness": 0
      },
      {
        "name": "strobe",
        "type": "strobe",
        "modulator": "bool",
        "brightness": 0,
        "speed": 0
      }
    ]
  }
        ----------------------------------------

        discovibe.json

        Content of discovibe.json:
        ----------------------------------------
{
    "name": "discovibe",
    "description": "Disco scene with alternating blue and pink slow waves",
    "type": "effect",
    "midi": 76,
    "key_command": "4",
    "lights": [
        {
            "name": "discoball",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": 100
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [0, 128],
            "brightness_range": [20, 60],
            "power_range": [0, 1]
        },
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.2,
            "min_brightness": 0,
            "max_brightness": 40,
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.24,
            "min_brightness": 0,
            "max_brightness": 40,
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.18,
            "min_brightness": 0,
            "max_brightness": 40,
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.22,
            "min_brightness": 20,
            "max_brightness": 30,
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.16,
            "min_brightness": 0,
            "max_brightness": 40,
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.26,
            "min_brightness": 0,
            "max_brightness": 30,
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.14,
            "min_brightness": 0,
            "max_brightness": 40,
            "color": "blue",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.28,
            "min_brightness": 0,
            "max_brightness": 30,
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "strobe",
            "type": "strobe",
            "modulator": "mfft",
            "threshold": 0.1,
            "brightness": 1,
            "mfft_range": [115, 127],
            "power_range": [0.0, 2.0],
            "speed": 1
        }
    ]
}
        ----------------------------------------

        red_echo.json

        Content of red_echo.json:
        ----------------------------------------
{"name": "red_echo", "description": "Red echo strobe.", "type": "build", "midi": 47, "key_command": "b", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.0, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.1, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.2, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.3, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.4, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.5, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.6, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.7, "min_brightness": 0, "max_brightness": 255, "color": "red", "strobe": 255}]}
        ----------------------------------------

        chill_white.json

        Content of chill_white.json:
        ----------------------------------------
{
    "name": "chill_white",
    "description": "All RGB lights set to white, subtly reactive to music",
    "type": "effect",
    "midi": 51,
    "key_command": "p",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 6],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 2],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 6],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 6],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 1],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 6],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 6],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [10, 70],
            "power_range": [0, 6],
            "brightness_range": [5, 255],
            "color": "white",
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        swamp.json

        Content of swamp.json:
        ----------------------------------------
{"name": "swamp", "description": "Eerie swamp scene with flickering blue and green lights", "type": "effect", "midi": 75, "key_command": "w", "lights": [{"name": "orb", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 20, "max_brightness": 100}, {"name": "ropes", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 10, "max_brightness": 50}, {"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "green", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "blue", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "green", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "blue", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "green", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "blue", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "green", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": "random", "min_brightness": 0, "max_brightness": 20, "color": "blue", "strobe": 0}]}
        ----------------------------------------

        hell.json

        Content of hell.json:
        ----------------------------------------
{"name": "hell", "description": "Stochastic red strobe on rgbs. All else off.", "type": "effect", "midi": 59, "key_command": "8", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": "random", "max_brightness": 50, "color": "red", "strobe": "random"}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "red", "strobe": "random"}]}
        ----------------------------------------

        discolaser.json

        Content of discolaser.json:
        ----------------------------------------
{"name": "discolaser", "description": "Disco scene w/ lasers", "type": "effect", "midi": 74, "key_command": "4", "lights": [{"name": "discoball", "type": "dimmer", "modulator": "bool", "brightness": 100}, {"name": "lasers", "type": "dimmer", "modulator": "bool", "brightness": 255}]}
        ----------------------------------------

        disco.json

        Content of disco.json:
        ----------------------------------------
{"name": "disco", "description": "Disco scene. Disco ball and RGB wavies.", "type": "effect", "midi": 72, "key_command": "4", "lights": [{"name": "discoball", "type": "dimmer", "modulator": "bool", "brightness": 100}]}
        ----------------------------------------

        red_pulse.json

        Content of red_pulse.json:
        ----------------------------------------
{"name": "red_pulse", "description": "All RGBs pulsing red, reactive to low frequencies", "key_command": "p", "midi": 42, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "red", "strobe": 0}]}
        ----------------------------------------

        blue.json

        Content of blue.json:
        ----------------------------------------
{"name": "blue", "description": "blue", "type": "effect", "midi": 79, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "color": "blue", "brightness": 255, "strobe": 0}]}
        ----------------------------------------

        vintage.json

        Content of vintage.json:
        ----------------------------------------
{"name": "vintage", "description": "Warm and cozy for acoustic songs.", "type": "effect", "midi": 69, "key_command": "v", "lights": [{"name": "ropes", "type": "dimmer", "modulator": "mfft", "mfft_range": [0, 50], "brightness_range": [50, 200], "power_range": [0, 5]}, {"name": "orb", "type": "dimmer", "modulator": "mfft", "mfft_range": [50, 128], "brightness_range": [60, 255], "power_range": [0, 0.3]}]}
        ----------------------------------------

        trance.json

        Content of trance.json:
        ----------------------------------------
{"name": "trance", "description": "All RGBs pulsing purple with a sine wave and maximum strobe", "key_command": "v", "midi": 54, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.2, "min_brightness": 0, "max_brightness": 255, "color": "purple", "strobe": 255}, {"name": "discoball", "type": "dimmer", "modulator": "bool", "brightness": 255}]}
        ----------------------------------------

        slime.json

        Content of slime.json:
        ----------------------------------------
{"name": "slime", "description": "Stochastic green strobe on all RGBs. All else off.", "type": "effect", "midi": 60, "key_command": "k", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": "random", "max_brightness": 255, "color": "green", "strobe": "random"}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": "random"}]}
        ----------------------------------------

        electric.json

        Content of electric.json:
        ----------------------------------------
{"name": "electric", "description": "Stochastic white strobe on rgbs. All else off.", "type": "effect", "midi": 65, "key_command": "5", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": "random", "max_brightness": 50, "color": "white", "strobe": "random"}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "white", "strobe": "random"}, {"name": "strobe", "type": "strobe", "modulator": "bool", "brightness": "random", "speed": "random"}]}
        ----------------------------------------

        build1.json

        Content of build1.json:
        ----------------------------------------
{"name": "build1", "description": "Gradually intensifying scene for track buildups", "type": "build", "midi": 45, "key_command": "b", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "mfft_range": [0, 16], "power_range": [0, 2], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [16, 32], "power_range": [0, 2], "brightness_range": [0, 255], "color": "purple", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [32, 48], "power_range": [0, 2], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [48, 64], "power_range": [0, 2], "brightness_range": [0, 255], "color": "purple", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [64, 80], "power_range": [0, 2], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [80, 96], "power_range": [0, 2], "brightness_range": [0, 255], "color": "purple", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [96, 112], "power_range": [0, 2], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [16, 32], "power_range": [0, 2], "brightness_range": [0, 255], "color": "purple", "strobe": 0}, {"name": "ropes", "type": "dimmer", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.75, "min_brightness": 0, "max_brightness": 90}, {"name": "orb", "type": "dimmer", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.25, "min_brightness": 0, "max_brightness": 100}]}
        ----------------------------------------

        wave.json

        Content of wave.json:
        ----------------------------------------
{
  "name": "wave",
  "description": "All blue RGB strobes with a slow sine wave pattern",
  "type": "effect",
  "midi": 80,
  "key_command": "w",
  "lights": [
    {
      "name": "rgb1",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb2",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb3",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb4",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb5",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb6",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb7",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    },
    {
      "name": "rgb8",
      "type": "rgb",
      "modulator": "time",
      "function": "sine",
      "frequency": 0.1,
      "min_brightness": 5,
      "max_brightness": 255,
      "color": "blue",
      "strobe": 0
    }
  ]
}
        ----------------------------------------

        fullstrobe.json

        Content of fullstrobe.json:
        ----------------------------------------
{"name": "fullstrobe", "description": "Full white strobe all (RGB+Strobe)", "type": "effect", "midi": 81, "key_command": "6", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "strobe", "type": "strobe", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 255, "speed": 245}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": 255, "color": "white", "strobe": 200}]}
        ----------------------------------------

        heart.json

        Content of heart.json:
        ----------------------------------------
{"name": "heart", "description": "Warm and cozy for acoustic songs.", "type": "effect", "midi": 73, "key_command": "v", "lights": [{"name": "orb", "type": "dimmer", "modulator": "mfft", "mfft_range": [0, 20], "brightness_range": [50, 255], "power_range": [0, 5]}]}
        ----------------------------------------

        chill_pink.json

        Content of chill_pink.json:
        ----------------------------------------
{"name": "chill_pink", "description": "All RGB lights set to pink, subtly reactive to music", "type": "effect", "midi": 39, "key_command": "p", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "color": "pink", "mfft_range": [0, 128], "power_range": [0, 0.5], "brightness_range": [10, 100], "strobe": 0}]}
        ----------------------------------------

        fairies.json

        Content of fairies.json:
        ----------------------------------------
{"name": "fairies", "description": "Stochastic purple strobe on all RGBs. All else off.", "type": "effect", "midi": 64, "key_command": "f", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "bool", "brightness": "random", "max_brightness": 255, "color": "purple", "strobe": "random"}, {"name": "rgb2", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}, {"name": "rgb3", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}, {"name": "rgb4", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}, {"name": "rgb7", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}, {"name": "rgb8", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "purple", "strobe": "random"}]}
        ----------------------------------------

        white_echo.json

        Content of white_echo.json:
        ----------------------------------------
{"name": "white_echo", "description": "White echo strobe.", "type": "build", "midi": 46, "key_command": "b", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.0, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.1, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.2, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.3, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.4, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.5, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.6, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "square", "frequency": 1.7, "min_brightness": 0, "max_brightness": 255, "color": "white", "strobe": 255}]}
        ----------------------------------------

        ambient1.json

        Content of ambient1.json:
        ----------------------------------------
{"name": "ambient1", "description": "Subtle, flowing colors for calmer moments", "type": "ambient", "midi": 38, "key_command": "a", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.1, "min_brightness": 0, "max_brightness": 100, "color": "blue"}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.08, "min_brightness": 0, "max_brightness": 100, "color": "purple"}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.12, "min_brightness": 0, "max_brightness": 100, "color": "blue"}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.09, "min_brightness": 0, "max_brightness": 100, "color": "purple"}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.11, "min_brightness": 0, "max_brightness": 100, "color": "blue"}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.07, "min_brightness": 0, "max_brightness": 100, "color": "purple"}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.13, "min_brightness": 0, "max_brightness": 100, "color": "blue"}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.06, "min_brightness": 0, "max_brightness": 100, "color": "purple"}, {"name": "ropes", "type": "dimmer", "modulator": "time", "function": "sine", "frequency": 0.05, "min_brightness": 0, "max_brightness": 75}, {"name": "orb", "type": "dimmer", "modulator": "time", "function": "sine", "frequency": 0.04, "min_brightness": 0, "max_brightness": 100}]}
        ----------------------------------------

        party.json

        Content of party.json:
        ----------------------------------------
{
    "name": "party",
    "description": "Default basic party scene :).",
    "type": "effect",
    "midi": 82,
    "key_command": "1",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 20],
            "mfft_range": [0, 20],
            "power_range": [0, 50],
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 20],
            "mfft_range": [50, 75],
            "power_range": [0, 1],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "mfft",
            "brightness": 100,
            "color": "pink",
            "strobe": 255,
            "mfft_range": [110, 127],
            "power_range": [0.001, 0.1],
            "brightness_range": [1, 25]
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "mfft",
            "mfft_range": [50, 90],
            "color": "blue",
            "power_range": [0.5, 1.0],
            "brightness_range": [0, 20],
            "strobe": 255
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 20],
            "mfft_range": [1, 3],
            "power_range": [0, 1],
            "color": "purple"
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "modulator": "time",
            "function": 0,
            "frequency": 0.2,
            "min_brightness": 20,
            "max_brightness": 40
        },
        {
            "name": "orb",
            "type": "dimmer",
            "modulator": "mfft",
            "mfft_range": [0, 10],
            "power_range": [0, 0.5],
            "brightness_range": [0, 40]
        },
        {
            "name": "discoball",
            "type": "dimmer",
            "modulator": "time",
            "function": "sine",
            "frequency": 0.05,
            "min_brightness": 0,
            "max_brightness": 255
        },
        {
            "name": "strobe",
            "type": "strobe",
            "modulator": "mfft",
            "threshold": 0.05,
            "brightness": 255,
            "mfft_range": [115, 127],
            "power_range": [0.08, 1.0],
            "speed": 1
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 50],
            "mfft_range": [1, 3],
            "power_range": [0, 5],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 20],
            "mfft_range": [15, 30],
            "power_range": [5, 100],
            "color": "green",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [1, 75],
            "mfft_range": [50, 75],
            "power_range": [0, 3],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "modulator": "bool",
            "brightness": "random"
        }
    ]
}
        ----------------------------------------

        whispers.json

        Content of whispers.json:
        ----------------------------------------
{"name": "whispers", "description": "A very dim, spooky scene with subtle, unsettling movements", "type": "effect", "midi": 83, "key_command": "w", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.05, "min_brightness": 0, "max_brightness": 20, "color": "blue", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.07, "min_brightness": 0, "max_brightness": 15, "color": "purple", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "triangle", "frequency": 0.03, "min_brightness": 0, "max_brightness": 25, "color": "green", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 20], "power_range": [0, 0.5], "brightness_range": [0, 30], "color": "blue", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sawtooth_backward", "frequency": 0.02, "min_brightness": 0, "max_brightness": 20, "color": "purple", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [20, 40], "power_range": [0, 0.5], "brightness_range": [0, 25], "color": "green", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.04, "min_brightness": 0, "max_brightness": 15, "color": "blue", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "triangle", "frequency": 0.06, "min_brightness": 0, "max_brightness": 20, "color": "purple", "strobe": 0}, {"name": "ropes", "type": "dimmer", "modulator": "time", "function": 1, "frequency": 0.01, "min_brightness": 0, "max_brightness": 30}, {"name": "orb", "type": "dimmer", "modulator": "mfft", "mfft_range": [0, 30], "power_range": [0, 0.3], "brightness_range": [0, 70]}]}
        ----------------------------------------

        blue_pulse.json

        Content of blue_pulse.json:
        ----------------------------------------
{"name": "blue_pulse", "description": "All RGBs pulsing blue, reactive to low frequencies", "key_command": "p", "midi": 43, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 0}]}
        ----------------------------------------

        blue_riser.json

        Content of blue_riser.json:
        ----------------------------------------
{"name": "blue_riser", "description": "blue riser strobe", "type": "build", "midi": 49, "key_command": "b", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sawtooth_forward", "frequency": 0.5, "min_brightness": 0, "max_brightness": 255, "color": "blue", "strobe": 255}]}
        ----------------------------------------

        goosebumps.json

        Content of goosebumps.json:
        ----------------------------------------
{"name": "goosebumps", "description": "Eerie lighting inspired by a creepy TV show intro", "type": "effect", "midi": 77, "key_command": "i", "lights": [{"name": "rgb1", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.5, "min_brightness": 0, "max_brightness": 50, "color": "green", "strobe": 0}, {"name": "rgb2", "type": "rgb", "modulator": "time", "function": "sine", "frequency": 0.5, "min_brightness": 0, "max_brightness": 175, "color": "green", "strobe": 0}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [0, 30], "power_range": [0, 1], "brightness_range": [0, 100], "color": "orange", "strobe": 0}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [30, 60], "power_range": [0, 1], "brightness_range": [0, 150], "color": "purple", "strobe": 0}, {"name": "rgb5", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": 0}, {"name": "rgb6", "type": "rgb", "modulator": "bool", "brightness": "random", "color": "green", "strobe": 0}, {"name": "rgb7", "type": "rgb", "modulator": "time", "function": "sawtooth_backward", "frequency": 0.25, "min_brightness": 0, "max_brightness": 100, "color": "green", "strobe": 0}, {"name": "rgb8", "type": "rgb", "modulator": "time", "function": "sawtooth_backward", "frequency": 0.25, "min_brightness": 0, "max_brightness": 100, "color": "green", "strobe": 0}, {"name": "ropes", "type": "dimmer", "modulator": "time", "function": 2, "frequency": 0.5, "min_brightness": 0, "max_brightness": 0}, {"name": "orb", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 50, "max_brightness": 100}, {"name": "ropes", "type": "dimmer", "modulator": "bool", "brightness": "random", "min_brightness": 50, "max_brightness": 70}, {"name": "strobe", "type": "strobe", "modulator": "bool", "brightness": 150, "speed": 100}]}
        ----------------------------------------

        hypno.json

        Content of hypno.json:
        ----------------------------------------
{"name": "hypno", "description": "All RGBs pulsing blue, reactive to low frequencies, strobe", "key_command": "p", "midi": 68, "lights": [{"name": "rgb1", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb2", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb3", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb4", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb5", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb6", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb7", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}, {"name": "rgb8", "type": "rgb", "modulator": "mfft", "mfft_range": [1, 20], "power_range": [0.5, 4], "brightness_range": [0, 255], "color": "blue", "strobe": 255}]}
        ----------------------------------------

    config/
        audio_parameters.json

        Content of audio_parameters.json:
        ----------------------------------------
{
    "SAMPLERATE": 16000,
    "BLOCKSIZE": 512,
    "NMFFT": 128
}
        ----------------------------------------

    scenes_staging/
        laser.json

        Content of laser.json:
        ----------------------------------------
{
    "name": "laser",
    "description": "Laser only",
    "key_command": "`",
    "midi": 96,
    "lights": [
        {
            "name": "laser", 
            "type": "laser",
            "modulator": "mfft",
            "power_range": [0.3, 0.5]
        }
    ]
}
        ----------------------------------------

        groove.json

        Content of groove.json:
        ----------------------------------------
{
    "name": "groove",
    "description": "Good for Gorillaz, Earth Wind Fire, Super Freak",
    "key_command": "g",
    "lights": [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "mfft",
            "brightness_range": [0, 255],
            "mfft_range": [1, 3],
            "power_range": [2, 15],
            "color": "pink",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "function": "sawtooth_forward",
            "frequency": 0.2,
            "min_brightness": 0,
            "max_brightness": 100,
            "color": "blue",
            "strobe": 0
        }
    ]

}
        ----------------------------------------

        wavies.json

        Content of wavies.json:
        ----------------------------------------
{
    "name": "wavies",
    "description": "Sine waves for testing.",
    "key_command": "-",
    "midi": 71,
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "red",
            "frequency": 0.75,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "green",
            "frequency": 0.5,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "blue",
            "frequency": 1.0,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "yellow",
            "frequency": 0.4,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "orange",
            "frequency": 0.3,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "purple",
            "frequency": 0.5,
            "function": "sine",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 0,
            "max_brightness": 255,
            "color": "green",
            "frequency": 0.1,
            "function": "sine",
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        white.json

        Content of white.json:
        ----------------------------------------
{
    "name": "white",
    "description": "White",
    "key_command": "0",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.5,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 2.7,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.8,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 0.9,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 2.2,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.3,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 2.7,
            "function": "sawtooth_forward",
            "strobe": 0
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "modulator": "time",
            "min_brightness": 50,
            "max_brightness": 255,
            "color": "white",
            "frequency": 1.8,
            "function": "sawtooth_forward",
            "strobe": 0
        }
    ]
}
        ----------------------------------------

        tension.json

        Content of tension.json:
        ----------------------------------------
{
    "name": "tension",
    "description": "For building towards a drop.",
    "key_command": "9",
    "lights": 
    [
        {
            "name": "rgb1", 
            "type": "rgb",
            "modulator": "bool",
            "brightness": 255,
            "color": "purple",
            "strobe": 0
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "modulator": "fft",
            "brightness": 100,
            "color": "blue",
            "strobe": 0,
            "frequency_range": [0, 1000],
            "power_range": [0, 1],
            "brightness_range": [0, 255]

        }
    ]

}
        ----------------------------------------

    scripts/
        extract_features.py

        Content of extract_features.py:
        ----------------------------------------

# %%
import librosa
import numpy as np
from pathlib import Path
import allin1
from allin1.helpers import save_results
from tqdm import tqdm
import json

# %%
songdir = Path('../../music/halloween2k24')
savedir = Path('../../music/halloween2k24_features')
songs = [str(i) for i in songdir.glob('*.mp3')]
# %%

def main():
	for s, song in enumerate(songs):
		# check if song has been processed
		if not Path(f'../../music/halloween2k24_features/{Path(song).stem}.json').exists():
			print(f"Processing song {s}: {song}")
			result = allin1.analyze(song, demix_dir='demix', keep_byproducts=True, include_activations=True, include_embeddings=True)
			save_results(result, savedir)
		else:
			print(f"{Path(song).stem} already processed. Skipping")
		
if __name__ == '__main__':
	main()

        ----------------------------------------

    profiles/
        testing.json

        Content of testing.json:
        ----------------------------------------
{
    "name": "testing",
    "description": "Testing profile. This works as the template lighting profile for running tests with two rgbs.",
    "lights": [
        {"name": "rgb1", "type": "rgb", "n_channels": 6},
        {"name": "rgb2", "type": "rgb", "n_channels": 6}
    ]
}
        ----------------------------------------

        laser.json

        Content of laser.json:
        ----------------------------------------
{
    "name": "laser",
    "description": "Laser testing profile. This works as the template lighting profile for running tests with the laser.",
    "lights": [
        {"name": "laser", "type": "laser", "n_channels": 10}
    ]
}
        ----------------------------------------

        garage.json

        Content of garage.json:
        ----------------------------------------
{
    "name": "garage",
    "description": "Garage",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "orb",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "discoball",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "strobe",
            "type": "strobe",
            "n_channels": 2
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "n_channels": 6
        }
    ]
}
        ----------------------------------------

        default.json

        Content of default.json:
        ----------------------------------------
{
    "name": "default",
    "description": "Default profile. This works as the template lighting profile for running tests.",
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "disco_ball",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "lamp",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "strobe",
            "type": "strobe",
            "n_channels": 2
        },
        {
            "name": "rgb",
            "type": "rgb",
            "n_channels": 7
        }
    ]
}
        ----------------------------------------

    oculizer/
        config.py

        Content of config.py:
        ----------------------------------------
import json
from pathlib import Path

def load_audio_parameters():
    current_dir = Path(__file__).resolve().parent
    json_path = current_dir.parent / 'config' / 'audio_parameters.json'
    
    with open(json_path, 'r') as f:
        return json.load(f)

audio_parameters = load_audio_parameters()
audio_parameters['HOP_LENGTH'] = int(audio_parameters['BLOCKSIZE'] / 2)
        ----------------------------------------

        interface.py

        Content of interface.py:
        ----------------------------------------
"""
interface.py

Description: This script provides a command line interface for toggling light mappings and controlling the Spotify API.

Author: Landry Bulls
Date: 8/20/24
"""

import curses
import keyboard
from audio import AudioListener
from control import LightController, SceneManager
import time

oculizer_title = """
      ___           ___           ___           ___                   ___           ___           ___     
     /\  \         /\  \         /\__\         /\__\      ___        /\  \         /\  \         /\  \    
    /::\  \       /::\  \       /:/  /        /:/  /     /\  \       \:\  \       /::\  \       /::\  \   
   /:/\:\  \     /:/\:\  \     /:/  /        /:/  /      \:\  \       \:\  \     /:/\:\  \     /:/\:\  \  
  /:/  \:\  \   /:/  \:\  \   /:/  /  ___   /:/  /       /::\__\       \:\  \   /::\~\:\  \   /::\~\:\  \ 
 /:/__/ \:\__\ /:/__/ \:\__\ /:/__/  /\__\ /:/__/     __/:/\/__/ _______\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ 
 \:\  \ /:/  / \:\  \  \/__/ \:\  \ /:/  / \:\  \    /\/:/  /    \::::::::/__/ \:\~\:\ \/__/ \/_|::\/:/  /
  \:\  /:/  /   \:\  \        \:\  /:/  /   \:\  \   \::/__/      \:\~~\~~      \:\ \:\__\      |:|::/  / 
   \:\/:/  /     \:\  \        \:\/:/  /     \:\  \   \:\__\       \:\  \        \:\ \/__/      |:|\/__/  
    \::/  /       \:\__\        \::/  /       \:\__\   \/__/        \:\__\        \:\__\        |:|  |    
     \/__/         \/__/         \/__/         \/__/                 \/__/         \/__/         \|__|    
"""

def main(stdscr):
    scene_manager = SceneManager('scenes_directory', 'profiles_directory')
    audio_listener = AudioListener()
    dmx_controller = Controller()
    light_controller = LightController(audio_listener, dmx_controller, scene_manager)

    audio_listener.start()
    light_controller.start()

    scenes = list(scene_manager.scenes.keys())
    current_scene_index = 0

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, oculizer_title)
        stdscr.addstr(1, 0, f"Current scene: {scenes[current_scene_index]}")
        stdscr.addstr(2, 0, "Press 'n' for next scene, 'p' for previous scene, 'q' to quit")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('n'):
            current_scene_index = (current_scene_index + 1) % len(scenes)
            scene_manager.set_scene(scenes[current_scene_index])
        elif key == ord('p'):
            current_scene_index = (current_scene_index - 1) % len(scenes)
            scene_manager.set_scene(scenes[current_scene_index])
        elif key == ord('q'):
            break

    audio_listener.stop()
    light_controller.stop()
    audio_listener.join()
    light_controller.join()

if __name__ == "__main__":
    curses.wrapper(main)



        ----------------------------------------

        __init__.py

        Content of __init__.py:
        ----------------------------------------
from oculizer.audio import AudioListener
from oculizer.light import Oculizer
from oculizer.light import mapping
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer
from oculizer.config import audio_parameters
from oculizer.custom_profiles.RGB import RGB
from oculizer.custom_profiles.ADJ_strobe import Strobe
from oculizer import utils
        ----------------------------------------

        utils.py

        Content of utils.py:
        ----------------------------------------
import os
import json

def load_json(filename):
    with open(filename, 'r') as f:
        data = json.load(f)
    return data
        ----------------------------------------

        visualizer.py

        Content of visualizer.py:
        ----------------------------------------
import sys
import numpy as np
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
from PyQt5.QtCore import QTimer
import pyqtgraph as pg
from oculizer import Oculizer, SceneManager
from oculizer.config import audio_parameters

nmfft = audio_parameters['NMFFT']

class FeatureVisualizer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("mfft Feature Visualizer")
        self.setGeometry(100, 100, 1000, 800)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.coeff_plot = pg.PlotWidget(title='Mel-scaled FFT Coefficients')
        layout.addWidget(self.coeff_plot)

        self.coeff_bars = pg.BarGraphItem(x=range(nmfft), height=[0]*nmfft, width=0.8, brush='b')
        self.coeff_plot.addItem(self.coeff_bars)

        self.coeff_plot.setLabel('left', 'Magnitude')
        self.coeff_plot.setLabel('bottom', 'mfft Coefficient')
        self.coeff_plot.showGrid(y=True)
        self.coeff_plot.setYRange(0, 20)  # Adjust based on your typical coefficient values
        self.coeff_plot.setXRange(-0.5, nmfft+0.5)
        x_axis = self.coeff_plot.getAxis('bottom')
        x_axis.setTicks([[(i, str(i+1)) if (i+1) % 5 == 0 else (i, '') for i in range(nmfft)]])
        x_axis.setStyle(tickTextOffset=10, tickLength=-15)

        # Initialize Oculizer controller
        scene_manager = SceneManager('scenes')
        self.controller = Oculizer('testing', scene_manager)
        self.controller.start()

        # Set up timer for updating plots
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(10)  # Update every 10 ms

    def update_plot(self):
        mfft = self.controller.mfft_queue.get()
        if mfft is not None and len(mfft) == nmfft:
            self.coeff_bars.setOpts(height=mfft)

    def closeEvent(self, event):
        self.controller.stop()
        self.controller.join()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    visualizer = FeatureVisualizer()
    visualizer.show()
    sys.exit(app.exec_())
        ----------------------------------------

        custom_profiles/
            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .ADJ_strobe import Strobe
from .RGB import RGB
            ----------------------------------------

            ADJ_strobe.py

            Content of ADJ_strobe.py:
            ----------------------------------------
from PyDMXControl.profiles.defaults import Fixture

class Strobe(Fixture):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._register_channel('dimmer')
        self._register_channel_aliases('dimmer', 'brightness', 'dim', 'd')
        self._register_channel('strobe')
        self._register_channel_aliases('strobe', 's')
        self._register_channel('function')
            ----------------------------------------

            RGB.py

            Content of RGB.py:
            ----------------------------------------
from PyDMXControl.profiles.defaults import Fixture

class RGB(Fixture):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._register_channel('dimmer')
        self._register_channel_aliases('dimmer', 'brightness', 'dim', 'd')
        self._register_channel('red')
        self._register_channel_aliases('red', 'r')
        self._register_channel('green')
        self._register_channel_aliases('green', 'g')
        self._register_channel('blue')
        self._register_channel_aliases('blue', 'b')
        self._register_channel('strobe')
        self._register_channel_aliases('strobe', 's')
        self._register_channel('function')

    def set_color(self, color):
        if color == 'red':
            self.set_channels(self.get_channels()[0], 255, 0, 0)
        elif color == 'orange':
            self.set_channels(self.get_channels()[0], 255, 127, 0)
        elif color == 'yellow':
            self.set_channels(self.get_channels()[0], 255, 255, 0)
        elif color == 'green':
            self.set_channels(self.get_channels()[0], 0, 255, 0)
        elif color == 'blue':
            self.set_channels(self.get_channels()[0], 0, 0, 255)
        elif color == 'purple':
            self.set_channels(self.get_channels()[0], 75, 0, 130)
        elif color == 'pink':
            self.set_channels(self.get_channels()[0], 255, 0, 255)
        elif color == 'white':
            self.set_channels(self.get_channels()[0], 255, 255, 255)
        else:
            raise ValueError(f"Color '{color}' not found")

    def set_strobe(self, speed, brightness):
        self.set_channels(255, 255, 255, speed, brightness, 0, 0)

            ----------------------------------------

        scenes/
            scene_manager.py

            Content of scene_manager.py:
            ----------------------------------------
import os
import json

class SceneManager:
    def __init__(self, scenes_directory):
        # two dirs up from the current file
        scenes_directory = os.path.join(os.path.dirname(__file__), '..', '..', scenes_directory)
        self.scenes = self.load_json_files(scenes_directory)
        self.current_scene = self.scenes[list(self.scenes.keys())[0]]

    def load_json_files(self, directory):
        data = {}
        for filename in os.listdir(directory):
            if filename.endswith('.json'):
                with open(os.path.join(directory, filename), 'r') as file:
                    data[filename[:-5]] = json.load(file)
        return data

    def set_scene(self, scene_name):
        if scene_name in self.scenes:
            self.current_scene = self.scenes[scene_name]
        else:
            raise ValueError(f"Scene '{scene_name}' not found")

    def reload_scenes(self):
        self.scenes = self.load_json_files('scenes')

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('testing')
    print(scene_manager.current_scene)

if __name__ == '__main__':
    main()
            ----------------------------------------

            scene_prediction.py

            Content of scene_prediction.py:
            ----------------------------------------
"""
Predict the lighting scene based on spotify features, real-time audio analysis, and user preferences. 
"""

import numpy as np
from scipy.spatial import distance
import time
import threading
import queue
import json
import os
import random
from config import audio_parameters
import librosa
from sklearn.cluster import KMeans


            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .scene_manager import SceneManager
            ----------------------------------------

        spotify/
            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .spotifizer import Spotifizer
            ----------------------------------------

            spotifizer.py

            Content of spotifizer.py:
            ----------------------------------------
import os
import json
import time
import threading
import queue
from spotipy import Spotify
from spotipy.oauth2 import SpotifyOAuth

class Spotifizer(threading.Thread):
    def __init__(self, client_id, client_secret, redirect_uri, update_interval=0.05, time_offset=0.5):
        super().__init__()
        self.running = threading.Event()
        self.error_queue = queue.Queue()
        self.info_queue = queue.Queue()
        self.auth_manager = self._create_auth_manager(client_id, client_secret, redirect_uri)
        self.spotify = self._initialize_spotify()
        self.playing = False
        self.current_track_id = None
        self.current_track_info = None 
        self.artist = None
        self.title = None
        self.update_interval = update_interval
        self.time_offset = time_offset  # Time offset in seconds
        self.progress = 0
        self.audio_analysis = None
        self.current_section = None
        self.last_update_time = 0
        self.audio_analysis_lock = threading.Lock()
        self.section_lock = threading.Lock()

    def _create_auth_manager(self, client_id, client_secret, redirect_uri):
        scopes = ['user-read-playback-state', 'user-modify-playback-state']
        return SpotifyOAuth(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            scope=' '.join(scopes)
        )

    def _initialize_spotify(self):
        token_info = self.auth_manager.get_cached_token()
        print(f"Initial token info: {token_info}")
        
        if token_info is None:
            print("No cached token found. Attempting to get new token...")
            token_info = self.auth_manager.get_access_token()
        elif self.auth_manager.is_token_expired(token_info):
            print("Token expired. Attempting to refresh...")
            if 'refresh_token' in token_info:
                token_info = self.auth_manager.refresh_access_token(token_info['refresh_token'])
            else:
                print("No refresh token available. Getting new token...")
                token_info = self.auth_manager.get_access_token()
        
        if token_info and 'access_token' in token_info:
            return Spotify(auth=token_info['access_token'])
        else:
            raise Exception("Failed to obtain valid Spotify access token")

    def run(self):
        self.running.set()
        while self.running.is_set():
            self._check_token()
            self.update_current_track()
            time.sleep(self.update_interval)

    def _check_token(self):
        if self.auth_manager.is_token_expired(self.auth_manager.get_cached_token()):
            token_info = self.auth_manager.refresh_access_token(self.auth_manager.get_cached_token()['refresh_token'])
            self.spotify = Spotify(auth=token_info['access_token'])

    def update_current_track(self):
        current_time = time.time()
        if current_time - self.last_update_time < self.update_interval:
            return

        current_playback = self.spotify.current_playback()
        if current_playback is not None and current_playback['is_playing']:
            self.playing = True
            new_track_id = current_playback['item']['id']
            self.progress = current_playback['progress_ms'] + int(self.time_offset * 1000)  # Add offset

            if new_track_id != self.current_track_id:
                self.current_track_id = new_track_id
                self.current_track_info = current_playback['item']
                self.artist = self.current_track_info['artists'][0]['name']
                self.title = self.current_track_info['name']
                self.fetch_audio_analysis()

            self.update_current_section()
        else:
            self.playing = False
            self.current_track_id = None
            self.current_track_info = None
            with self.audio_analysis_lock:
                self.audio_analysis = None
            with self.section_lock:
                self.current_section = None

        self.last_update_time = current_time

    def fetch_audio_analysis(self):
        filename = f"song_data/{self.current_track_id}.json"
        
        # Check if the audio analysis file already exists
        if os.path.exists(filename):
            try:
                with open(filename, 'r') as f:
                    self.audio_analysis = json.load(f)
                print(f"Loaded existing audio analysis for track {self.current_track_id}")
                return
            except json.JSONDecodeError:
                print(f"Error reading existing audio analysis file for track {self.current_track_id}. Will fetch from API.")

        # If file doesn't exist or couldn't be read, fetch from API
        try:
            analysis = self.spotify.audio_analysis(self.current_track_id)
            with self.audio_analysis_lock:
                self.audio_analysis = analysis
            self.save_audio_analysis()
        except Exception as e:
            self.error_queue.put(f"Error fetching audio analysis: {str(e)}")

    def save_audio_analysis(self):
        if not os.path.exists('song_data'):
            os.makedirs('song_data')
        
        filename = f"song_data/{self.current_track_id}.json"
        
        # Check if the file already exists
        if not os.path.exists(filename):
            with open(filename, 'w') as f:
                json.dump(self.audio_analysis, f)
            print(f"Saved new audio analysis for track {self.current_track_id}")
        else:
            print(f"Audio analysis file already exists for track {self.current_track_id}. Not overwriting.")

    def update_current_section(self):
        with self.audio_analysis_lock:
            if self.audio_analysis and 'sections' in self.audio_analysis:
                for section in self.audio_analysis['sections']:
                    section_start = section['start'] * 1000
                    section_end = section_start + (section['duration'] * 1000)
                    if section_start <= self.progress < section_end:
                        with self.section_lock:
                            self.current_section = section
                        break

    def seek_to_timestamp(self, timestamp_ms):
        try:
            self.spotify.seek_track(timestamp_ms)
            self.progress = timestamp_ms
        except Exception as e:
            self.error_queue.put(f"Error seeking to timestamp: {str(e)}")

    def loop_current_section(self):
        if self.current_section:
            start_ms = int(self.current_section['start'] * 1000)
            duration_ms = int(self.current_section['duration'] * 1000)
            end_ms = start_ms + duration_ms

            if self.progress >= end_ms:
                self.seek_to_timestamp(start_ms)

    def stop(self):
        self.running.clear()

def main():
    # Read the credentials from the file
    credspath = os.path.join(os.path.dirname(__file__), '../../spotify_credentials.txt')
    with open(credspath) as f:
        lines = f.readlines()
        client_id = lines[0].strip().split(' ')[1]
        client_secret = lines[1].strip().split(' ')[1]
        redirect_uri = lines[2].strip().split(' ')[1]

    spotifizer = Spotifizer(client_id, client_secret, redirect_uri, update_interval=0.05, time_offset=1.0)
    spotifizer.start()

    try:
        while True:
            if spotifizer.playing and spotifizer.current_track_info:
                print(f"\nNow playing: {spotifizer.title} by {spotifizer.artist}")
                with spotifizer.section_lock:
                    current_section = spotifizer.current_section
                if current_section:
                    with spotifizer.audio_analysis_lock:
                        if spotifizer.audio_analysis and 'sections' in spotifizer.audio_analysis:
                            try:
                                section_index = spotifizer.audio_analysis['sections'].index(current_section)
                                total_sections = len(spotifizer.audio_analysis['sections'])
                                print(f"Current section: {section_index + 1}/{total_sections}")
                                print(f"Section start time: {current_section['start']:.2f}s")
                                print(f"Section duration: {current_section['duration']:.2f}s")
                                print(f"Current progress: {spotifizer.progress / 1000:.2f}s")
                                print(f"Section loudness: {current_section['loudness']:.2f}dB")
                                print(f"Section tempo: {current_section['tempo']:.2f} BPM")
                                print(f"Section key: {current_section['key']}")
                                print(f"Section mode: {'Major' if current_section['mode'] == 1 else 'Minor'}")
                            except ValueError:
                                print("Section information temporarily unavailable")
                else:
                    print("Waiting for section information...")
            else:
                print("Waiting for track to start playing...")
            
            time.sleep(0.1)  # Update every 0.1 seconds
    
    except KeyboardInterrupt:
        print("\nStopping Spotifizer...")
        spotifizer.stop()
        spotifizer.join()

if __name__ == "__main__":
    main()
            ----------------------------------------

        audio/
            audio_listener.py

            Content of audio_listener.py:
            ----------------------------------------
import threading
import queue
import numpy as np
from scipy.fftpack import rfft
import time
import curses
import sounddevice as sd
from oculizer.config import audio_parameters

SAMPLERATE = audio_parameters['SAMPLERATE']
BLOCKSIZE = audio_parameters['BLOCKSIZE']

def get_blackhole_device_idx():
    devices = sd.query_devices()
    for i, device in enumerate(devices):
        if 'BlackHole' in device['name']:
            return i, device['name']
    return None, None

class AudioListener(threading.Thread):
    def __init__(self, sample_rate=SAMPLERATE, block_size=BLOCKSIZE, channels=1):
        threading.Thread.__init__(self)
        self.sample_rate = sample_rate
        self.block_size = block_size
        self.channels = channels
        self.audio_queue = queue.Queue()
        self.fft_queue = queue.Queue()
        self.running = threading.Event()
        self.error_queue = queue.Queue()
        self.device_idx, self.device_name = get_blackhole_device_idx()
        self.stream = None

    def audio_callback(self, indata, frames, time, status):
        if status:
            self.error_queue.put(f"Audio callback error: {status}")
        try:
            audio_data = indata.copy().flatten()
            fft_data = np.abs(rfft(audio_data))
            self.audio_queue.put(audio_data)
            self.fft_queue.put(fft_data)
        except Exception as e:
            self.error_queue.put(f"Error processing audio data: {str(e)}")

    def run(self):
        self.running.set()
        try:
            with sd.InputStream(
                device=self.device_idx,
                channels=self.channels,
                samplerate=self.sample_rate,
                blocksize=self.block_size,
                callback=self.audio_callback
            ):
                while self.running.is_set():
                    sd.sleep(100)
        except Exception as e:
            self.error_queue.put(f"Error in audio stream: {str(e)}")

    def stop(self):
        self.running.clear()

    def get_audio_data(self):
        try:
            return self.audio_queue.get_nowait()
        except queue.Empty:
            return None

    def get_fft_data(self, timeout=0.08):
        try:
            return self.fft_queue.get(timeout=timeout)
        except queue.Empty:
            return None

    def get_errors(self):
        errors = []
        while not self.error_queue.empty():
            errors.append(self.error_queue.get_nowait())
        return errors

def main():
    stdscr = curses.initscr()

    audio_listener = AudioListener()
    audio_listener.start()
    print('Listening to audio...')

    try:
        while True:
            audio_data = audio_listener.get_audio_data()
            fft_data = audio_listener.get_fft_data()
            errors = audio_listener.get_errors()
            
            stdscr.clear()
            if fft_data is not None:
                stdscr.addstr(0, 1, f"FFT Sum: {np.sum(fft_data)}")
                stdscr.addstr(1, 1, f'FFT Shape: {len(fft_data)}')
            stdscr.addstr(2, 1, f"Sample rate: {audio_listener.sample_rate}")
            stdscr.addstr(3, 1, f"Block size: {audio_listener.block_size}")
            stdscr.refresh()

            if errors:
                print("Errors occurred:", errors)

            if audio_data is not None and fft_data is not None:
                # Process data here
                pass

            time.sleep(0.01)  # Small delay to prevent busy-waiting
    except KeyboardInterrupt:
        print("Stopping audio listener...")
    finally:
        audio_listener.stop()
        audio_listener.join()
        curses.endwin()

if __name__ == "__main__":
    main()
            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .audio_listener import AudioListener

            ----------------------------------------

        light/
            control.py

            Content of control.py:
            ----------------------------------------
"""
light_control.py

Description: This script provides all the lighting control. It is responsible for controlling the DMX lights and RGB lights, loading profiles, 
setting up the DMX controller, providing functions for sending signals to the DMX controller, and providing functions for controlling the RGB lights.

Author: Landry Bulls
Date: 8/20/24
"""

import numpy as np
import sounddevice as sd
from librosa.feature import melspectrogram
from PyDMXControl.controllers import OpenDMXController
from PyDMXControl.profiles.Generic import Dimmer, Custom
from oculizer.custom_profiles.RGB import RGB
from oculizer.custom_profiles.ADJ_strobe import Strobe
from oculizer.scenes import SceneManager
from oculizer.light.mapping import process_light, scale_mfft
from oculizer.config import audio_parameters
from oculizer.utils import load_json
import threading
import queue
import time
from pathlib import Path

class Oculizer(threading.Thread):
    def __init__(self, profile_name, scene_manager):
        threading.Thread.__init__(self)
        self.profile_name = profile_name
        self.sample_rate = audio_parameters['SAMPLERATE']
        self.block_size = audio_parameters['BLOCKSIZE']
        self.hop_length = audio_parameters['HOP_LENGTH']
        self.channels = 1
        self.mfft_queue = queue.Queue(maxsize=1)
        self.device_idx = self._get_blackhole_device_idx()
        self.running = threading.Event()
        self.scene_manager = scene_manager
        self.profile = self._load_profile()
        self.light_names = [i['name'] for i in self.profile['lights']]
        self.dmx_controller, self.controller_dict = self._load_controller()
        self.scene_changed = threading.Event()

    def _get_blackhole_device_idx(self):
        devices = sd.query_devices()
        for i, device in enumerate(devices):
            if 'BlackHole' in device['name']:
                return i
        return None

    def _load_profile(self):
        current_dir = Path(__file__).resolve().parent
        project_root = current_dir.parent.parent
        profile_path = project_root / 'profiles' / f'{self.profile_name}.json'
        return load_json(profile_path)

    def _load_controller(self):
        controller = OpenDMXController()
        control_dict = {}
        curr_channel = 1
        sleeptime = 0.1

        for light in self.profile['lights']:
            if light['type'] == 'dimmer':
                control_dict[light['name']] = controller.add_fixture(Dimmer(name=light['name'], start_channel=curr_channel))
                curr_channel += 1
                control_dict[light['name']].dim(255)
                time.sleep(sleeptime)
                control_dict[light['name']].dim(0)

            elif light['type'] == 'rgb':
                control_dict[light['name']] = controller.add_fixture(RGB(name=light['name'], start_channel=curr_channel))
                curr_channel += 6
                control_dict[light['name']].set_channels([255, 255, 255, 255, 255, 0])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0, 0, 0, 0, 0, 0])

            elif light['type'] == 'strobe':
                control_dict[light['name']] = controller.add_fixture(Strobe(name=light['name'], start_channel=curr_channel))
                curr_channel += 2
                control_dict[light['name']].set_channels([255, 255])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0, 0])

            elif light['type'] == 'laser':
                control_dict[light['name']] = controller.add_fixture(Custom(name=light['name'], start_channel=curr_channel, channels=10))
                curr_channel += 10
                control_dict[light['name']].set_channels([128, 0, 0, 0, 0, 0, 0, 0, 0, 0])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0] * 10)
                time.sleep(sleeptime)

        return controller, control_dict

    def audio_callback(self, indata, frames, time, status):
        if status:
            print(f"Audio callback error: {status}")
            return
        
        audio_data = indata.copy().flatten()
        mfft_data = np.mean(melspectrogram(y=audio_data, sr=self.sample_rate, n_fft=self.block_size, hop_length=self.hop_length), axis=1)
        mfft_data = scale_mfft(mfft_data)
        
        if self.mfft_queue.full():
            try:
                self.mfft_queue.get_nowait()
            except queue.Empty:
                pass
        self.mfft_queue.put(mfft_data)

    def run(self):
        self.running.set()
        try:
            with sd.InputStream(
                device=self.device_idx,
                channels=self.channels,
                samplerate=self.sample_rate,
                blocksize=self.block_size,
                callback=self.audio_callback
            ):
                while self.running.is_set():
                    self.process_audio_and_lights()
                    time.sleep(0.001)
        except Exception as e:
            print(f"Error in audio stream: {str(e)}")
            print(f"Origin script: {e.__traceback__.tb_frame.f_globals['__file__']}")    

    def process_audio_and_lights(self):
        if self.scene_changed.is_set():
            self.scene_changed.clear()
            self.turn_off_all_lights()

        try:
            mfft_data = self.mfft_queue.get(block=False)
        except queue.Empty:
            return

        current_time = time.time()

        for light in self.scene_manager.current_scene['lights']:
            if light['name'] not in self.light_names:
                # turn off lights that are not in the profile
                if light['type'] == 'dimmer':
                    self.controller_dict[light['name']].dim(0)
                elif light['type'] == 'rgb':
                    self.controller_dict[light['name']].set_channels([0, 0, 0, 0, 0, 0])
                elif light['type'] == 'strobe':
                    self.controller_dict[light['name']].set_channels([0, 0])
                elif light['type'] == 'laser':
                    self.controller_dict[light['name']].set_channels([0] * 10)
                continue

            try:
                dmx_values = process_light(light, mfft_data, current_time)
                if dmx_values is not None:
                    if light['type'] == 'dimmer':
                        self.controller_dict[light['name']].dim(dmx_values[0])

                    elif light['type'] == 'rgb':
                        self.controller_dict[light['name']].set_channels(dmx_values[:6])

                    elif light['type'] == 'strobe':
                        self.controller_dict[light['name']].set_channels(dmx_values[:2])

                    elif light['type'] == 'laser':
                        self.controller_dict[light['name']].set_channels(dmx_values[:10])

            except Exception as e:
                print(f"Error processing light {light['name']}: {str(e)}")


    def change_scene(self, scene_name):
        self.turn_off_all_lights()
        self.scene_manager.set_scene(scene_name)
        self.scene_changed.set()
        self.process_audio_and_lights()  # Apply the new scene immediately
        #self.dmx_controller.update()  # Ensure new scene DMX signals are sent

    def turn_off_all_lights(self):
        for light_name, light_fixture in self.controller_dict.items():
            if hasattr(light_fixture, 'dim'):
                light_fixture.dim(0)
            elif hasattr(light_fixture, 'set_channels'):
                light_fixture.set_channels([0] * light_fixture.channels)
        
        # Ensure DMX signals are sent
        #self.dmx_controller.update()
        time.sleep(0.1)  # Small delay to ensure DMX signals are processed

    def stop(self):
        self.running.clear()

def main():
    # init scene manager
    scene_manager = SceneManager('scenes')
    # set the initial scene to the test scene
    scene_manager.set_scene('testing')  
    # init the light controller with the name of the profile and the scene manager
    controller = Oculizer('testing', scene_manager)
    print("Starting Oculizer...")
    controller.start()
    
    try:
        while True:
            time.sleep(1)  # Main thread does nothing but keep the program alive
    except KeyboardInterrupt:
        print("Stopping Oculizer...")
        controller.stop()
        controller.join()

if __name__ == "__main__":
    main()







            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
#from .control import load_controller, load_json, load_profile, Oculizer
from .control import Oculizer

            ----------------------------------------

            mapping.py

            Content of mapping.py:
            ----------------------------------------
import numpy as np
import time
from oculizer.config import audio_parameters

SAMPLERATE = audio_parameters['SAMPLERATE']
BLOCKSIZE = audio_parameters['BLOCKSIZE']

COLORS = np.array([
    [255, 0, 0],    # red
    [255, 127, 0],  # orange
    [255, 255, 0],  # yellow
    [0, 255, 0],    # green
    [0, 0, 255],    # blue
    [75, 0, 130],   # purple
    [255, 0, 255],  # pink
    [255, 255, 255] # white
], dtype=np.int32)

COLOR_NAMES = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink', 'white']

def scale_mfft(mfft_vec, scaling_factor=10.0, scaling_method='log'):
    num_bins = len(mfft_vec)
    if scaling_method == 'log':
        scaling = np.log1p(np.arange(num_bins) / num_bins) * scaling_factor + 1
    elif scaling_method == 'exp':
        scaling = np.exp(np.arange(num_bins) / num_bins * scaling_factor)
    elif scaling_method == 'linear':
        scaling = np.linspace(1, 1 + scaling_factor, num_bins)
    else:
        raise ValueError("Invalid scaling method. Choose 'log', 'exp', or 'linear'.")
    scaling /= scaling.mean()
    return mfft_vec * scaling

def color_to_rgb(color_name):
    return COLORS[COLOR_NAMES.index(color_name)] if color_name in COLOR_NAMES else COLORS[np.random.randint(0, len(COLOR_NAMES))]

def freq_to_index(freq):
    return int(freq * BLOCKSIZE / SAMPLERATE)

def power_to_brightness(power, power_range, brightness_range):
    power_low, power_high = power_range
    brightness_low, brightness_high = brightness_range
    if power <= power_low:
        return brightness_low
    elif power >= power_high:
        return brightness_high
    else:
        return int((power - power_low) / (power_high - power_low) * (brightness_high - brightness_low) + brightness_low)

def mfft_to_value(mfft_vec, mfft_range, power_range, value_range):
    mfft_low, mfft_high = int(mfft_range[0]), int(mfft_range[1])
    if mfft_low < 0 or mfft_high > len(mfft_vec):
        raise ValueError(f"MFFT range {mfft_range} is out of bounds for MFFT vector of length {len(mfft_vec)}")
    mfft_mean = np.mean(mfft_vec[mfft_low:mfft_high])
    return power_to_brightness(mfft_mean, power_range, value_range)

def time_function(t, frequency, function):
    functions = {
        'sine': lambda t, f: np.sin(t * f * 2 * np.pi) * 0.5 + 0.5,
        'square': lambda t, f: np.sign(np.sin(t * f * 2 * np.pi)) * 0.5 + 0.5,
        'triangle': lambda t, f: np.abs(((t * f) % 2) - 1),
        'sawtooth_forward': lambda t, f: (t * f) % 1,
        'sawtooth_backward': lambda t, f: 1 - (t * f % 1)
    }
    return functions.get(function, functions['sine'])(t, frequency)

def process_mfft(light, mfft_vec):
    mfft_range = light.get('mfft_range', (0, len(mfft_vec)))
    power_range = light.get('power_range', (0, 1))
    value_range = light.get('brightness_range', (0, 255))
    
    if light['type'] == 'dimmer':
        return [mfft_to_value(mfft_vec, mfft_range, power_range, value_range)]
    elif light['type'] == 'rgb':
        brightness = mfft_to_value(mfft_vec, mfft_range, power_range, value_range)
        color = color_to_rgb(light.get('color', 'random'))
        strobe = light.get('strobe', 0)
        return [brightness, *color, strobe, 0]
    elif light['type'] == 'strobe':
        threshold = light.get('threshold', 0.5)
        mfft_mean = np.mean(mfft_vec[mfft_range[0]:mfft_range[1]])
        return [255, 255] if mfft_mean >= threshold else [0, 0]
    elif light['type'] == 'laser':
        zoom_range = light.get('zoom_range', [0, 127])
        speed_range = light.get('speed_range', [0, 255])
        mfft_power = np.mean(mfft_vec)
        channels = [0] * 10
        channels[0] = 0
        if mfft_power <= power_range[0]:
            channels[1], channels[3], channels[9] = 0, zoom_range[0], speed_range[0]
        else:
            channels[1], channels[2] = 255, np.random.randint(0, 256)
            if mfft_power >= power_range[1]:
                channels[3], channels[9] = zoom_range[1], speed_range[1]
            else:
                power_ratio = (mfft_power - power_range[0]) / (power_range[1] - power_range[0])
                channels[3] = int(zoom_range[0] + power_ratio * (zoom_range[1] - zoom_range[0]))
                channels[9] = int(speed_range[0] + power_ratio * (speed_range[1] - speed_range[0]))
        return channels

def process_bool(light):
    if light['type'] == 'dimmer':
        if light['brightness']=='random':
            brightness = np.random.randint(light.get('min_brightness', 0), light.get('max_brightness', 255) + 1)
        else:
            brightness = light.get('brightness', 255)
        return [brightness]
    elif light['type'] == 'rgb':
        if light.get('brightness', 'random') == 'random':
            min_brightness = light.get('min_brightness', 0)
            max_brightness = light.get('max_brightness', 255)
            brightness = np.random.randint(min_brightness, max_brightness + 1)
        else:
            brightness = light.get('brightness', 255)
        color = color_to_rgb(light.get('color', 'random'))
        strobe = np.random.randint(0, 256) if light.get('strobe', 'random') == 'random' else light.get('strobe', 0)
        colorfade = light.get('colorfade', 0)
        return [brightness, *color, strobe, colorfade]
    elif light['type'] == 'strobe':
        speed = np.random.randint(0, 256) if light.get('speed', 'random') == 'random' else light.get('speed', 255)
        brightness = np.random.randint(0, 256) if light.get('brightness', 'random') == 'random' else light.get('brightness', 255)
        return [speed, brightness]
    elif light['type'] == 'laser':
        return [128, 255] + [0] * 8

def time_function(t, frequency, function):
    functions = {
        'sine': lambda t, f: np.sin(t * f * 2 * np.pi) * 0.5 + 0.5,
        'square': lambda t, f: np.sign(np.sin(t * f * 2 * np.pi)) * 0.5 + 0.5,
        'triangle': lambda t, f: np.abs(((t * f) % 2) - 1),
        'sawtooth_forward': lambda t, f: (t * f) % 1,
        'sawtooth_backward': lambda t, f: 1 - (t * f % 1)
    }
    
    # Convert integer input to corresponding string
    if isinstance(function, int):
        function_names = list(functions.keys())
        if 0 <= function < len(function_names):
            function = function_names[function]
        else:
            function = 'sine'  # Default to sine if integer is out of range
    
    # Use the specified function or default to sine
    return functions.get(function, functions['sine'])(t, frequency)

def process_time(light, current_time):
    t = current_time
    frequency = light.get('frequency', 1)
    function = light.get('function', 'sine')
    min_value = light.get('min_brightness', 0)
    max_value = light.get('max_brightness', 255)
    value = int(min_value + (max_value - min_value) * time_function(t, frequency, function))
    
    if light['type'] == 'dimmer':
        return [value]
    elif light['type'] == 'rgb':
        color = color_to_rgb(light.get('color', 'random'))
        strobe = light.get('strobe', 0)
        return [value, *color, strobe, 0]
    elif light['type'] == 'strobe':
        target = light.get('target', 'both')
        speed_range = light.get('speed_range', [0, 255])
        brightness_range = light.get('brightness_range', [0, 255])
        if target == 'speed':
            return [value, brightness_range[1]]
        elif target == 'brightness':
            return [speed_range[1], value]
        else:
            speed = int(speed_range[0] + (speed_range[1] - speed_range[0]) * time_function(t, frequency, function))
            brightness = int(brightness_range[0] + (brightness_range[1] - brightness_range[0]) * time_function(t, frequency, function))
            return [speed, brightness]

def process_light(light, mfft_vec, current_time):
    modulator = light.get('modulator', 'bool')
    
    if modulator == 'mfft':
        return process_mfft(light, mfft_vec)
    elif modulator == 'bool':
        return process_bool(light)
    elif modulator == 'time':
        return process_time(light, current_time)
    
    return None

def main():
    mfft_data = np.random.rand(128)
    light = {
        'modulator': 'mfft',
        'type': 'rgb',
        'mfft_range': (0, 128),
        'power_range': (0, 1),
        'brightness_range': (0, 255),
        'color': 'random',
        'strobe': 0
    }
    dmx_values = process_light(light, mfft_data, time.time())
    print(dmx_values)

if __name__ == "__main__":
    main()




            ----------------------------------------
