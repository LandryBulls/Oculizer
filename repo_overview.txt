Oculizer/
    run_garage.py

    Content of run_garage.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('blue')
    light_controller = Oculizer('garage', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")

        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    requirements.txt

    Content of requirements.txt:
    ----------------------------------------

    ----------------------------------------

    run_full.py

    Content of run_full.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('hell')
    light_controller = Oculizer('garage', scene_manager)
    spotifizer = Spotifizer()

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()
    spotifizer.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
            
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    ----------------------------------------

    test_imports.py

    Content of test_imports.py:
    ----------------------------------------
from oculizer import AudioListener, LightController, SceneManager, AudioLightController
from oculizer.config import audio_parameters
import time

print("AudioListener imported successfully")
print("LightController imported successfully")
print("SceneManager imported successfully")
print(f"Audio parameters: {audio_parameters}")

# Instantiate AudioListener to ensure it works
listener = AudioListener()
print("AudioListener instantiated successfully")

listener.start()  # Use start() instead of run()
time.sleep(2)
listener.stop()
listener.join()  # Wait for the thread to finish
print('AudioListener started, stopped, and joined successfully')

# Instantiate LightController to ensure it works
controller = LightController(listener, 'testing', SceneManager('scenes'))
print("LightController instantiated successfully")

controller.start()  # Use start() instead of run()
time.sleep(2)
controller.stop()
controller.join()  # Wait for the thread to finish
print('LightController started, stopped, and joined successfully')

# Instantiate SceneManager to ensure it works
manager = SceneManager('scenes')
print("SceneManager instantiated successfully")

print('SceneManager started, stopped, and joined successfully')

print("All imports and instantiations successful")
    ----------------------------------------

    spotify_credentials.txt

    Content of spotify_credentials.txt:
    ----------------------------------------
id d97b8894dcb848469851a24585519de8
secret 7fcdd929f0a545bdaebfdc30c1d74993
uri http://localhost:8000
username 1260351083
token BQBQeSU-AUrZhmSfOjwP1MHtniul_YZl4JjmL8yM2QbRWQDK7SmMGZjHi4WShgG6lhis9ijRKDiqV3DSenSZ0WL-3PcZhIIcDyVW1SBfdLnPkufRB9qIxyKVGOSd0tCXFncJh9Kq7dforq2F5uP4PBsNOjU85B3Tq1CaVdv01UuFCKsLue9PGEaIN_XIPCMITsBTC8j92vliY_at5fK4BvGQI2LFEZCS61OxmyXqhwSNIyr3n-no-0312CM9CHPkBEYhvAPp10GnPHJkspD-YRG0NWYG-fSDmkQ-SkvZOOJ-BWvI


    ----------------------------------------

    prepare_repo.py

    Content of prepare_repo.py:
    ----------------------------------------
import os

def is_relevant_file(filename):
    relevant_extensions = ('.py', '.json', '.md', '.txt')
    irrelevant_patterns = ('__pycache__', '.vscode', '.DS_Store', '.gitignore')
    return filename.endswith(relevant_extensions) and not any(pattern in filename for pattern in irrelevant_patterns)

def generate_repo_overview(root_dir):
    overview = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Remove hidden directories and files from the walk
        dirnames[:] = [d for d in dirnames if not d.startswith('.')]
        filenames = [f for f in filenames if not f.startswith('.') and is_relevant_file(f)]
        
        if not filenames:  # Skip empty directories
            continue
        
        level = dirpath.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        overview.append(f'{indent}{os.path.basename(dirpath)}/')
        sub_indent = ' ' * 4 * (level + 1)
        for f in filenames:
            overview.append(f'{sub_indent}{f}')
            file_path = os.path.join(dirpath, f)
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                overview.append(f'\n{sub_indent}Content of {f}:')
                overview.append(f'{sub_indent}' + '-' * 40)
                overview.append(content)
                overview.append(f'{sub_indent}' + '-' * 40 + '\n')
    
    return '\n'.join(overview)

def main():
    root_dir = os.getcwd()  # Get the current working directory
    output_file = 'repo_overview.txt'
    
    repo_overview = generate_repo_overview(root_dir)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(repo_overview)
    
    print(f"Repository overview has been generated and saved to {output_file}")

if __name__ == "__main__":
    main()
    ----------------------------------------

    __init__.py

    Content of __init__.py:
    ----------------------------------------
from .audio.audio_listener import AudioListener
from .light.control import LightController
from .scenes.scene_manager import SceneManager



    ----------------------------------------

    run_dev.py

    Content of run_dev.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
from PyQt5.QtCore import QTimer
import pyqtgraph as pg

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager
from oculizer.config import audio_parameters

nmfft = audio_parameters['NMFFT']

class MFFTVisualizer(QMainWindow):
    def __init__(self, light_controller):
        super().__init__()
        self.setWindowTitle("MFFT Visualizer")
        self.setGeometry(100, 100, 800, 400)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.mfft_plot = pg.PlotWidget(title='Mel-scaled FFT')
        layout.addWidget(self.mfft_plot)

        self.mfft_bars = pg.BarGraphItem(x=range(nmfft), height=[0]*nmfft, width=0.8, brush='b')
        self.mfft_plot.addItem(self.mfft_bars)

        self.mfft_plot.setLabel('left', 'Magnitude')
        self.mfft_plot.setLabel('bottom', 'MFFT Coefficient')
        self.mfft_plot.showGrid(y=True)
        self.mfft_plot.setYRange(0, 20)
        self.mfft_plot.setXRange(-0.5, nmfft+0.5)

        self.light_controller = light_controller

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(10)  # Update every 10 ms

    def update_plot(self):
        try:
            mfft = self.light_controller.mfft_queue.get(block=False)
            if mfft is not None and len(mfft) == nmfft:
                self.mfft_bars.setOpts(height=mfft)
        except queue.Empty:
            pass

def curses_thread(stdscr, scene_manager, light_controller):
    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")

        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")
        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('blue')
    light_controller = Oculizer('garage', scene_manager)

    light_controller.start()

    app = QApplication(sys.argv)
    visualizer = MFFTVisualizer(light_controller)
    visualizer.show()

    curses_thread_obj = threading.Thread(target=curses_thread, args=(stdscr, scene_manager, light_controller))
    curses_thread_obj.start()

    app.exec_()

    light_controller.stop()
    light_controller.join()
    curses_thread_obj.join()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    README.md

    Content of README.md:
    ----------------------------------------
```    
          ___           ___           ___           ___                   ___           ___           ___     
         /\  \         /\  \         /\__\         /\__\      ___        /\  \         /\  \         /\  \    
        /::\  \       /::\  \       /:/  /        /:/  /     /\  \       \:\  \       /::\  \       /::\  \   
       /:/\:\  \     /:/\:\  \     /:/  /        /:/  /      \:\  \       \:\  \     /:/\:\  \     /:/\:\  \  
      /:/  \:\  \   /:/  \:\  \   /:/  /  ___   /:/  /       /::\__\       \:\  \   /::\~\:\  \   /::\~\:\  \ 
     /:/__/ \:\__\ /:/__/ \:\__\ /:/__/  /\__\ /:/__/     __/:/\/__/ _______\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ 
     \:\  \ /:/  / \:\  \  \/__/ \:\  \ /:/  / \:\  \    /\/:/  /    \::::::::/__/ \:\~\:\ \/__/ \/_|::\/:/  /
      \:\  /:/  /   \:\  \        \:\  /:/  /   \:\  \   \::/__/      \:\~~\~~      \:\ \:\__\      |:|::/  / 
       \:\/:/  /     \:\  \        \:\/:/  /     \:\  \   \:\__\       \:\  \        \:\ \/__/      |:|\/__/  
        \::/  /       \:\__\        \::/  /       \:\__\   \/__/        \:\__\        \:\__\        |:|  |    
         \/__/         \/__/         \/__/         \/__/                 \/__/         \/__/         \|__|    


```

Intelligent, real-time audio-reactive DMX lighting. 

In active development. 

    ----------------------------------------

    run_midi.py

    Content of run_midi.py:
    ----------------------------------------
import os
import json
import threading
import queue
import numpy as np
import curses
import time
import mido

from oculizer.light import Oculizer
from oculizer.scenes import SceneManager

def create_midi_scene_map(scenes):
    midi_scene_map = {}
    for scene_name, scene_data in scenes.items():
        if 'midi' in scene_data:
            midi_scene_map[scene_data['midi']] = scene_name
    return midi_scene_map

def init_colors():
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_BLUE, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)
    curses.init_pair(6, curses.COLOR_CYAN, -1)
    curses.init_pair(7, curses.COLOR_WHITE, -1)

def main(stdscr):
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('party')  # Set an initial scene
    light_controller = Oculizer('garage', scene_manager)

    # Create MIDI scene map from scene configurations
    midi_scene_map = create_midi_scene_map(scene_manager.scenes)

    light_controller.start()

    # Open the MIDI input port
    try:
        inport = mido.open_input()
    except IOError:
        stdscr.addstr(0, 0, "No MIDI input port found. Please connect a MIDI device and restart.")
        stdscr.refresh()
        time.sleep(5)
        return

    stdscr.nodelay(1)  # Make getch non-blocking

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}", curses.color_pair(2))
        stdscr.addstr(1, 0, "Available scenes:")
        for i, (scene, data) in enumerate(scene_manager.scenes.items()):
            midi_note = data.get('midi', 'N/A')
            stdscr.addstr(i+3, 0, f"{scene} | MIDI Note: {midi_note} | Key: {data.get('key_command', 'N/A')}")

        stdscr.addstr(len(scene_manager.scenes)+2, 0, "Press 'q' to quit. Press 'r' to reload scenes.", curses.color_pair(5))
        stdscr.refresh()

        # Check for MIDI input
        for msg in inport.iter_pending():
            if msg.type == 'note_on':
                if msg.note in midi_scene_map:
                    try:
                        light_controller.change_scene(midi_scene_map[msg.note])
                    except Exception as e:
                        stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        # Check for keyboard input
        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key == ord('r'):
            scene_manager.reload_scenes()
            midi_scene_map = create_midi_scene_map(scene_manager.scenes)  # Recreate MIDI map
            light_controller.change_scene(scene_manager.current_scene['name'])
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)
        elif key != -1:  # -1 is returned if no key is pressed
            key_char = chr(key) if 0 <= key <= 255 else None
            if key_char in [scene['key_command'] for scene in scene_manager.scenes.values() if 'key_command' in scene]:
                for scene, data in scene_manager.scenes.items():
                    if data.get('key_command') == key_char:
                        light_controller.change_scene(scene)
                        break

        time.sleep(0.01)  # Short sleep to prevent CPU hogging

    curses.endwin()

if __name__ == '__main__':
    curses.wrapper(main)
    ----------------------------------------

    setup.py

    Content of setup.py:
    ----------------------------------------
from setuptools import setup, find_packages

setup(
    name="oculizer",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        # List your dependencies here
        'numpy',
        'scipy',
        'sounddevice',
        'librosa',
        'pydub',
        'scipy', 
        'sounddevice',
        'soundfile',
        'sklearn',
        'PyDMXControl'
    ],
)
    ----------------------------------------

    run_printer.py

    Content of run_printer.py:
    ----------------------------------------
import mido
import time

def print_midi_notes():
    print("MIDI Note Printer")
    print("=================")
    print("Press keys on your MIDI keyboard to see their note numbers.")
    print("Press Ctrl+C to exit.")
    print()

    try:
        with mido.open_input() as inport:
            print(f"Listening on MIDI input: {inport.name}")
            print()
            
            while True:
                for msg in inport.iter_pending():
                    if msg.type == 'note_on':
                        note_name = msg.note
                        print(f" Number: {msg.note:3d}") # Name: {note_name:>3}, Velocity: {msg.velocity:3d}")
                    # elif msg.type == 'note_off':
                    #     note_name = msg.note
                    #     print(f"Note Off - Number: {msg.note:3d}, Name: {note_name:>3}, Velocity: {msg.velocity:3d}")
                time.sleep(0.01)  # Short sleep to prevent CPU hogging
                
    except KeyboardInterrupt:
        print("\nExiting...")

if __name__ == "__main__":
    print_midi_notes()
    ----------------------------------------

    run_tester.py

    Content of run_tester.py:
    ----------------------------------------
"""
For testing the functionality of the program.
"""

import os
import json
import threading
import queue
import numpy as np
import curses
import time

#from control import load_json, load_profile, load_controller, LightController
from oculizer.light import Oculizer
from oculizer.audio import AudioListener
from oculizer.scenes import SceneManager

stdscr = curses.initscr()

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('hell')
    light_controller = Oculizer('testing', scene_manager)

    scene_commands = {ord(scene_manager.scenes[scene]['key_command']): scene for scene in scene_manager.scenes}

    light_controller.start()

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, f"Current scene: {scene_manager.current_scene['name']}")
        stdscr.addstr(1, 0, "Available scenes:")
        for i, scene in enumerate(scene_manager.scenes):
            stdscr.addstr(i+2, 0, f"{scene} | Commands: {scene_manager.scenes[scene]['key_command']}")
        # highlight the current scene
        stdscr.addstr(2+list(scene_manager.scenes.keys()).index(scene_manager.current_scene['name']), 0, f"{scene_manager.current_scene['name']}", curses.A_REVERSE)
        stdscr.addstr(len(scene_manager.scenes)+3, 0, f"Press 'q' to quit. Press 'r' to reload scenes.")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('q'):
            light_controller.stop()
            light_controller.join()
            break
        elif key in scene_commands:
            try:
                light_controller.change_scene(scene_commands[key])
            except Exception as e:
                stdscr.addstr(len(scene_manager.scenes)+2, 0, f"Error changing scene: {str(e)}")

        elif key == ord('r'):
            scene_manager.reload_scenes()
            light_controller.change_scene(scene_manager.current_scene['name'])  # Reapply current scene
            stdscr.addstr(len(scene_manager.scenes)+2, 0, "Scenes reloaded.")
            stdscr.refresh()
            time.sleep(1)

        stdscr.refresh()
        time.sleep(0.1)

    curses.endwin()

if __name__ == '__main__':
    main()

    config/
        audio_parameters.json

        Content of audio_parameters.json:
        ----------------------------------------
{
    "SAMPLERATE": 16000,
    "BLOCKSIZE": 512,
    "NMFFT": 128
}
        ----------------------------------------

    oculizer.egg-info/
        SOURCES.txt

        Content of SOURCES.txt:
        ----------------------------------------
README.md
setup.py
custom_profiles/ADJ_strobe.py
custom_profiles/RGB.py
custom_profiles/__init__.py
oculizer/__init__.py
oculizer/config.py
oculizer/interface.py
oculizer/utils.py
oculizer/visualizer.py
oculizer.egg-info/PKG-INFO
oculizer.egg-info/SOURCES.txt
oculizer.egg-info/dependency_links.txt
oculizer.egg-info/requires.txt
oculizer.egg-info/top_level.txt
oculizer/audio/__init__.py
oculizer/audio/audio_listener.py
oculizer/light/__init__.py
oculizer/light/control.py
oculizer/light/mapping.py
oculizer/scenes/__init__.py
oculizer/scenes/scene_manager.py
oculizer/scenes/scene_prediction.py
oculizer/spotify/__init__.py
oculizer/spotify/spotifizer.py
        ----------------------------------------

        requires.txt

        Content of requires.txt:
        ----------------------------------------
numpy
scipy
sounddevice
librosa
pyaudio
pydub
scipy
sounddevice
soundfile
sklearn
PyDMXControl

        ----------------------------------------

        top_level.txt

        Content of top_level.txt:
        ----------------------------------------
custom_profiles
oculizer

        ----------------------------------------

        dependency_links.txt

        Content of dependency_links.txt:
        ----------------------------------------


        ----------------------------------------

    scripts/
        extract_features.py

        Content of extract_features.py:
        ----------------------------------------

# %%
import librosa
import numpy as np
from pathlib import Path
import allin1
from allin1.helpers import save_results
from tqdm import tqdm
import json

# %%
songdir = Path('../../music/halloween2k24')
savedir = Path('../../music/halloween2k24_features')
songs = [str(i) for i in songdir.glob('*.mp3')]
# %%

def main():
	for s, song in enumerate(songs):
		# check if song has been processed
		if not Path(f'../../music/halloween2k24_features/{Path(song).stem}.json').exists():
			print(f"Processing song {s}: {song}")
			result = allin1.analyze(song, demix_dir='demix', keep_byproducts=True, include_activations=True, include_embeddings=True)
			save_results(result, savedir)
		else:
			print(f"{Path(song).stem} already processed. Skipping")
		
if __name__ == '__main__':
	main()

        ----------------------------------------

    profiles/
        testing.json

        Content of testing.json:
        ----------------------------------------
{
    "name": "testing",
    "description": "Testing profile. This works as the template lighting profile for running tests with two rgbs.",
    "lights": [
        {"name": "rgb1", "type": "rgb", "n_channels": 6},
        {"name": "rgb2", "type": "rgb", "n_channels": 6}
    ]
}
        ----------------------------------------

        garage.json

        Content of garage.json:
        ----------------------------------------
{
    "name": "garage",
    "description": "Garage",
    "lights": [
        {
            "name": "rgb1",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb2",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb3",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb4",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "orb",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "discoball",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "ropes",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "rgb5",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb6",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "strobe",
            "type": "strobe",
            "n_channels": 2
        },
        {
            "name": "rgb7",
            "type": "rgb",
            "n_channels": 6
        },
        {
            "name": "rgb8",
            "type": "rgb",
            "n_channels": 6
        }
    ]
}
        ----------------------------------------

        default.json

        Content of default.json:
        ----------------------------------------
{
    "name": "default",
    "description": "Default profile. This works as the template lighting profile for running tests.",
    "lights": [
        {
            "name": "ropes",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "disco_ball",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "lasers",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "lamp",
            "type": "dimmer",
            "n_channels": 1
        },
        {
            "name": "strobe",
            "type": "strobe",
            "n_channels": 2
        },
        {
            "name": "rgb",
            "type": "rgb",
            "n_channels": 7
        }
    ]
}
        ----------------------------------------

    oculizer/
        config.py

        Content of config.py:
        ----------------------------------------
import json
from pathlib import Path

def load_audio_parameters():
    current_dir = Path(__file__).resolve().parent
    json_path = current_dir.parent / 'config' / 'audio_parameters.json'
    
    with open(json_path, 'r') as f:
        return json.load(f)

audio_parameters = load_audio_parameters()
audio_parameters['HOP_LENGTH'] = int(audio_parameters['BLOCKSIZE'] / 2)
        ----------------------------------------

        interface.py

        Content of interface.py:
        ----------------------------------------
"""
interface.py

Description: This script provides a command line interface for toggling light mappings and controlling the Spotify API.

Author: Landry Bulls
Date: 8/20/24
"""

import curses
import keyboard
from audio import AudioListener
from control import LightController, SceneManager
import time

oculizer_title = """
      ___           ___           ___           ___                   ___           ___           ___     
     /\  \         /\  \         /\__\         /\__\      ___        /\  \         /\  \         /\  \    
    /::\  \       /::\  \       /:/  /        /:/  /     /\  \       \:\  \       /::\  \       /::\  \   
   /:/\:\  \     /:/\:\  \     /:/  /        /:/  /      \:\  \       \:\  \     /:/\:\  \     /:/\:\  \  
  /:/  \:\  \   /:/  \:\  \   /:/  /  ___   /:/  /       /::\__\       \:\  \   /::\~\:\  \   /::\~\:\  \ 
 /:/__/ \:\__\ /:/__/ \:\__\ /:/__/  /\__\ /:/__/     __/:/\/__/ _______\:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\ 
 \:\  \ /:/  / \:\  \  \/__/ \:\  \ /:/  / \:\  \    /\/:/  /    \::::::::/__/ \:\~\:\ \/__/ \/_|::\/:/  /
  \:\  /:/  /   \:\  \        \:\  /:/  /   \:\  \   \::/__/      \:\~~\~~      \:\ \:\__\      |:|::/  / 
   \:\/:/  /     \:\  \        \:\/:/  /     \:\  \   \:\__\       \:\  \        \:\ \/__/      |:|\/__/  
    \::/  /       \:\__\        \::/  /       \:\__\   \/__/        \:\__\        \:\__\        |:|  |    
     \/__/         \/__/         \/__/         \/__/                 \/__/         \/__/         \|__|    
"""

def main(stdscr):
    scene_manager = SceneManager('scenes_directory', 'profiles_directory')
    audio_listener = AudioListener()
    dmx_controller = Controller()
    light_controller = LightController(audio_listener, dmx_controller, scene_manager)

    audio_listener.start()
    light_controller.start()

    scenes = list(scene_manager.scenes.keys())
    current_scene_index = 0

    while True:
        stdscr.clear()
        stdscr.addstr(0, 0, oculizer_title)
        stdscr.addstr(1, 0, f"Current scene: {scenes[current_scene_index]}")
        stdscr.addstr(2, 0, "Press 'n' for next scene, 'p' for previous scene, 'q' to quit")
        stdscr.refresh()

        key = stdscr.getch()
        if key == ord('n'):
            current_scene_index = (current_scene_index + 1) % len(scenes)
            scene_manager.set_scene(scenes[current_scene_index])
        elif key == ord('p'):
            current_scene_index = (current_scene_index - 1) % len(scenes)
            scene_manager.set_scene(scenes[current_scene_index])
        elif key == ord('q'):
            break

    audio_listener.stop()
    light_controller.stop()
    audio_listener.join()
    light_controller.join()

if __name__ == "__main__":
    curses.wrapper(main)



        ----------------------------------------

        __init__.py

        Content of __init__.py:
        ----------------------------------------
from oculizer.audio import AudioListener
from oculizer.light import Oculizer
from oculizer.light import mapping
from oculizer.scenes import SceneManager
from oculizer.spotify import Spotifizer
from oculizer.config import audio_parameters
from oculizer.custom_profiles.RGB import RGB
from oculizer.custom_profiles.ADJ_strobe import Strobe
from oculizer import utils
        ----------------------------------------

        utils.py

        Content of utils.py:
        ----------------------------------------
import os
import json

def load_json(filename):
    with open(filename, 'r') as f:
        data = json.load(f)
    return data
        ----------------------------------------

        visualizer.py

        Content of visualizer.py:
        ----------------------------------------
import sys
import numpy as np
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget
from PyQt5.QtCore import QTimer
import pyqtgraph as pg
from oculizer import Oculizer, SceneManager
from oculizer.config import audio_parameters

nmfft = audio_parameters['NMFFT']

class FeatureVisualizer(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("mfft Feature Visualizer")
        self.setGeometry(100, 100, 1000, 800)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        self.coeff_plot = pg.PlotWidget(title='Mel-scaled FFT Coefficients')
        layout.addWidget(self.coeff_plot)

        self.coeff_bars = pg.BarGraphItem(x=range(nmfft), height=[0]*nmfft, width=0.8, brush='b')
        self.coeff_plot.addItem(self.coeff_bars)

        self.coeff_plot.setLabel('left', 'Magnitude')
        self.coeff_plot.setLabel('bottom', 'mfft Coefficient')
        self.coeff_plot.showGrid(y=True)
        self.coeff_plot.setYRange(0, 20)  # Adjust based on your typical coefficient values
        self.coeff_plot.setXRange(-0.5, nmfft+0.5)
        x_axis = self.coeff_plot.getAxis('bottom')
        x_axis.setTicks([[(i, str(i+1)) if (i+1) % 5 == 0 else (i, '') for i in range(nmfft)]])
        x_axis.setStyle(tickTextOffset=10, tickLength=-15)

        # Initialize Oculizer controller
        scene_manager = SceneManager('scenes')
        self.controller = Oculizer('testing', scene_manager)
        self.controller.start()

        # Set up timer for updating plots
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(10)  # Update every 10 ms

    def update_plot(self):
        mfft = self.controller.mfft_queue.get()
        if mfft is not None and len(mfft) == nmfft:
            self.coeff_bars.setOpts(height=mfft)

    def closeEvent(self, event):
        self.controller.stop()
        self.controller.join()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    visualizer = FeatureVisualizer()
    visualizer.show()
    sys.exit(app.exec_())
        ----------------------------------------

        custom_profiles/
            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .ADJ_strobe import Strobe
from .RGB import RGB
            ----------------------------------------

            ADJ_strobe.py

            Content of ADJ_strobe.py:
            ----------------------------------------
from PyDMXControl.profiles.defaults import Fixture

class Strobe(Fixture):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._register_channel('dimmer')
        self._register_channel_aliases('dimmer', 'brightness', 'dim', 'd')
        self._register_channel('strobe')
        self._register_channel_aliases('strobe', 's')
        self._register_channel('function')
            ----------------------------------------

            RGB.py

            Content of RGB.py:
            ----------------------------------------
from PyDMXControl.profiles.defaults import Fixture

class RGB(Fixture):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._register_channel('dimmer')
        self._register_channel_aliases('dimmer', 'brightness', 'dim', 'd')
        self._register_channel('red')
        self._register_channel_aliases('red', 'r')
        self._register_channel('green')
        self._register_channel_aliases('green', 'g')
        self._register_channel('blue')
        self._register_channel_aliases('blue', 'b')
        self._register_channel('strobe')
        self._register_channel_aliases('strobe', 's')
        self._register_channel('function')

    def set_color(self, color):
        if color == 'red':
            self.set_channels(self.get_channels()[0], 255, 0, 0)
        elif color == 'orange':
            self.set_channels(self.get_channels()[0], 255, 127, 0)
        elif color == 'yellow':
            self.set_channels(self.get_channels()[0], 255, 255, 0)
        elif color == 'green':
            self.set_channels(self.get_channels()[0], 0, 255, 0)
        elif color == 'blue':
            self.set_channels(self.get_channels()[0], 0, 0, 255)
        elif color == 'purple':
            self.set_channels(self.get_channels()[0], 75, 0, 130)
        elif color == 'pink':
            self.set_channels(self.get_channels()[0], 255, 0, 255)
        elif color == 'white':
            self.set_channels(self.get_channels()[0], 255, 255, 255)
        else:
            raise ValueError(f"Color '{color}' not found")

    def set_strobe(self, speed, brightness):
        self.set_channels(255, 255, 255, speed, brightness, 0, 0)

            ----------------------------------------

        scenes/
            scene_manager.py

            Content of scene_manager.py:
            ----------------------------------------
import os
import json

class SceneManager:
    def __init__(self, scenes_directory):
        # two dirs up from the current file
        scenes_directory = os.path.join(os.path.dirname(__file__), '..', '..', scenes_directory)
        self.scenes = self.load_json_files(scenes_directory)
        self.current_scene = self.scenes[list(self.scenes.keys())[0]]

    def load_json_files(self, directory):
        data = {}
        for filename in os.listdir(directory):
            if filename.endswith('.json'):
                with open(os.path.join(directory, filename), 'r') as file:
                    data[filename[:-5]] = json.load(file)
        return data

    def set_scene(self, scene_name):
        if scene_name in self.scenes:
            self.current_scene = self.scenes[scene_name]
        else:
            raise ValueError(f"Scene '{scene_name}' not found")

    def reload_scenes(self):
        self.scenes = self.load_json_files('scenes')

def main():
    scene_manager = SceneManager('scenes')
    scene_manager.set_scene('testing')
    print(scene_manager.current_scene)

if __name__ == '__main__':
    main()
            ----------------------------------------

            scene_prediction.py

            Content of scene_prediction.py:
            ----------------------------------------
"""
Predict the lighting scene based on spotify features, real-time audio analysis, and user preferences. 
"""

import numpy as np
from scipy.spatial import distance
import time
import threading
import queue
import json
import os
import random
from config import audio_parameters
import librosa
from sklearn.cluster import KMeans


            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
from .scene_manager import SceneManager
            ----------------------------------------

        spotify/
            __init__.py

            Content of __init__.py:
            ----------------------------------------
light_control.py

Description: This script provides all the lighting control. It is responsible for controlling the DMX lights and RGB lights, loading profiles, 
setting up the DMX controller, providing functions for sending signals to the DMX controller, and providing functions for controlling the RGB lights.

Author: Landry Bulls
Date: 8/20/24
"""

import numpy as np
import sounddevice as sd
from librosa.feature import melspectrogram
from PyDMXControl.controllers import OpenDMXController
from PyDMXControl.profiles.Generic import Dimmer, Custom
from oculizer.custom_profiles.RGB import RGB
from oculizer.custom_profiles.ADJ_strobe import Strobe
from oculizer.scenes import SceneManager
from oculizer.light.mapping import process_light, scale_mfft
from oculizer.config import audio_parameters
from oculizer.utils import load_json
import threading
import queue
import time
from pathlib import Path

class Oculizer(threading.Thread):
    def __init__(self, profile_name, scene_manager):
        threading.Thread.__init__(self)
        self.profile_name = profile_name
        self.sample_rate = audio_parameters['SAMPLERATE']
        self.block_size = audio_parameters['BLOCKSIZE']
        self.hop_length = audio_parameters['HOP_LENGTH']
        self.channels = 1
        self.mfft_queue = queue.Queue(maxsize=1)
        self.device_idx = self._get_blackhole_device_idx()
        self.running = threading.Event()
        self.scene_manager = scene_manager
        self.profile = self._load_profile()
        self.light_names = [i['name'] for i in self.profile['lights']]
        self.dmx_controller, self.controller_dict = self._load_controller()
        self.scene_changed = threading.Event()

    def _get_blackhole_device_idx(self):
        devices = sd.query_devices()
        for i, device in enumerate(devices):
            if 'BlackHole' in device['name']:
                return i
        return None

    def _load_profile(self):
        current_dir = Path(__file__).resolve().parent
        project_root = current_dir.parent.parent
        profile_path = project_root / 'profiles' / f'{self.profile_name}.json'
        return load_json(profile_path)

    def _load_controller(self):
        controller = OpenDMXController()
        control_dict = {}
        curr_channel = 1
        sleeptime = 0.1

        for light in self.profile['lights']:
            if light['type'] == 'dimmer':
                control_dict[light['name']] = controller.add_fixture(Dimmer(name=light['name'], start_channel=curr_channel))
                curr_channel += 1
                control_dict[light['name']].dim(255)
                time.sleep(sleeptime)
                control_dict[light['name']].dim(0)

            elif light['type'] == 'rgb':
                control_dict[light['name']] = controller.add_fixture(RGB(name=light['name'], start_channel=curr_channel))
                curr_channel += 6
                control_dict[light['name']].set_channels([255, 255, 255, 255, 255, 0])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0, 0, 0, 0, 0, 0])

            elif light['type'] == 'strobe':
                control_dict[light['name']] = controller.add_fixture(Strobe(name=light['name'], start_channel=curr_channel))
                curr_channel += 2
                control_dict[light['name']].set_channels([255, 255])
                time.sleep(sleeptime)
                control_dict[light['name']].set_channels([0, 0])

        return controller, control_dict

    def audio_callback(self, indata, frames, time, status):
        if status:
            print(f"Audio callback error: {status}")
            return
        
        audio_data = indata.copy().flatten()
        mfft_data = np.mean(melspectrogram(y=audio_data, sr=self.sample_rate, n_fft=self.block_size, hop_length=self.hop_length), axis=1)
        mfft_data = scale_mfft(mfft_data)
        
        if self.mfft_queue.full():
            try:
                self.mfft_queue.get_nowait()
            except queue.Empty:
                pass
        self.mfft_queue.put(mfft_data)

    def run(self):
        self.running.set()
        try:
            with sd.InputStream(
                device=self.device_idx,
                channels=self.channels,
                samplerate=self.sample_rate,
                blocksize=self.block_size,
                callback=self.audio_callback
            ):
                while self.running.is_set():
                    self.process_audio_and_lights()
                    time.sleep(0.001)
        except Exception as e:
            print(f"Error in audio stream: {str(e)}")
            print(f"Origin script: {e.__traceback__.tb_frame.f_globals['__file__']}")    

    def process_audio_and_lights(self):
        if self.scene_changed.is_set():
            self.scene_changed.clear()
            self.turn_off_all_lights()

        try:
            mfft_data = self.mfft_queue.get(block=False)
        except queue.Empty:
            return

        current_time = time.time()

        for light in self.scene_manager.current_scene['lights']:
            if light['name'] not in self.light_names:
                continue

            try:
                dmx_values = process_light(light, mfft_data, current_time)
                if dmx_values is not None:
                    if light['type'] == 'dimmer':
                        self.controller_dict[light['name']].dim(dmx_values[0])

                    elif light['type'] == 'rgb':
                        self.controller_dict[light['name']].set_channels(dmx_values[:6])

                    elif light['type'] == 'strobe':
                        self.controller_dict[light['name']].set_channels(dmx_values[:2])

            except Exception as e:
                print(f"Error processing light {light['name']}: {str(e)}")


    def change_scene(self, scene_name):
        self.scene_manager.set_scene(scene_name)
        self.scene_changed.set()

    def turn_off_all_lights(self):
        for light in self.profile['lights']:
            if light['type'] == 'dimmer':
                self.controller_dict[light['name']].dim(0)
            elif light['type'] == 'rgb':
                self.controller_dict[light['name']].set_channels([0, 0, 0, 0, 0, 0])
            elif light['type'] == 'strobe':
                self.controller_dict[light['name']].set_channels([0, 0])

    def stop(self):
        self.running.clear()

def main():
    # init scene manager
    scene_manager = SceneManager('scenes')
    # set the initial scene to the test scene
    scene_manager.set_scene('testing')  
    # init the light controller with the name of the profile and the scene manager
    controller = Oculizer('testing', scene_manager)
    print("Starting Oculizer...")
    controller.start()
    
    try:
        while True:
            time.sleep(1)  # Main thread does nothing but keep the program alive
    except KeyboardInterrupt:
        print("Stopping Oculizer...")
        controller.stop()
        controller.join()

if __name__ == "__main__":
    main()







            ----------------------------------------

            __init__.py

            Content of __init__.py:
            ----------------------------------------
#from .control import load_controller, load_json, load_profile, Oculizer
from .control import Oculizer

            ----------------------------------------

            mapping.py

            Content of mapping.py:
            ----------------------------------------
import numpy as np
import time
from oculizer.config import audio_parameters

SAMPLERATE = audio_parameters['SAMPLERATE']
BLOCKSIZE = audio_parameters['BLOCKSIZE']

# Define colors as a numpy array for faster operations
COLORS = np.array([
    [255, 0, 0],    # red
    [255, 127, 0],  # orange
    [255, 255, 0],  # yellow
    [0, 255, 0],    # green
    [0, 0, 255],    # blue
    [75, 0, 130],   # purple
    [255, 0, 255],  # pink
    [255, 255, 255] # white
], dtype=np.int32)

COLOR_NAMES = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink', 'white']

# Helper function to convert color name to index
def color_to_index(color_name):
    return COLOR_NAMES.index(color_name) if color_name in COLOR_NAMES else -1

def scale_mfft(mfft_vec, scaling_factor=10.0, scaling_method='log'):
    """
    Scale the MFFT vector to boost higher frequencies.
    
    :param mfft_vec: The input MFFT vector
    :param scaling_factor: Controls the intensity of scaling (higher values = more intense scaling)
    :param scaling_method: The method of scaling ('log', 'exp', or 'linear')
    :return: Scaled MFFT vector
    """
    num_bins = len(mfft_vec)
    
    if scaling_method == 'log':
        # Logarithmic scaling
        scaling = np.log1p(np.arange(num_bins) / num_bins) * scaling_factor + 1

    elif scaling_method == 'exp':
        # Exponential scaling
        scaling = np.exp(np.arange(num_bins) / num_bins * scaling_factor)

    elif scaling_method == 'linear':
        # Linear scaling
        scaling = np.linspace(1, 1 + scaling_factor, num_bins)
    else:
        raise ValueError("Invalid scaling method. Choose 'log', 'exp', or 'linear'.")
    
    # Normalize the scaling factor
    scaling /= scaling.mean()
    
    # Apply scaling
    scaled_mfft = mfft_vec * scaling
    
    return scaled_mfft

def color_to_rgb(color_name):
    # returns the RGB value of the color
    return COLORS[COLOR_NAMES.index(color_name)]

def random_color():
    # choose a random color and returns its rgb value
    return color_to_rgb(COLOR_NAMES[np.random.randint(0, len(COLOR_NAMES))])

# def generate_RGB_signal(brightness=255, color_index=0, strobe=0, colorfade=0):
#     color = COLORS[color_index]
#     return [int(brightness), int(color[0]), int(color[1]), int(color[2]), int(strobe), int(colorfade)]

def freq_to_index(freq):
    return int(freq * BLOCKSIZE / SAMPLERATE)

def power_to_brightness(power, power_low, power_high, brightness_low, brightness_high):
    if power < power_low:
        return brightness_low
    elif power > power_high:
        return brightness_high
    else:
        return int((power - power_low) / (power_high - power_low) * (brightness_high - brightness_low) + brightness_low)

def mfft_to_brightness(mfft_vec, mfft_range, power_range, brightness_range):
    mfft_low, mfft_high = int(mfft_range[0]), int(mfft_range[1])
    if mfft_low < 0 or mfft_high > len(mfft_vec):
        raise ValueError(f"MFFT range {mfft_range} is out of bounds for MFFT vector of length {len(mfft_vec)}")
    mfft_mean = np.max(mfft_vec[mfft_low:mfft_high])
    return power_to_brightness(mfft_mean, power_range[0], power_range[1], brightness_range[0], brightness_range[1])

def mfft_to_rgb(mfft_vec, mfft_range, power_range, brightness_range, color, strobe):
    try:
        brightness = mfft_to_brightness(mfft_vec, mfft_range, power_range, brightness_range)
        
        if color == 'random':
            color = color_to_rgb(random_color())
        else:
            color = color_to_rgb(color)
        
        return [int(brightness), int(color[0]), int(color[1]), int(color[2]), int(strobe), 0]

    except Exception as e:
        print(f"Error in mfft_to_rgb: {str(e)}")
        return [0, 0, 0, 0, 0, 0]  # Return a safe default value

def mfft_to_dimmer(mfft_vec, mfft_range, prange, brange):
    try:
        mfft_low, mfft_high = int(mfft_range[0]), int(mfft_range[1])
        if mfft_low < 0 or mfft_high > len(mfft_vec):
            raise ValueError(f"MFFT range {mfft_range} is out of bounds for MFFT vector of length {len(mfft_vec)}")
        mfft_mean = np.mean(mfft_vec[mfft_low:mfft_high])
        return int(power_to_brightness(mfft_mean, prange[0], prange[1], brange[0], brange[1]))

    except Exception as e:
        print(f"Error in mfft_to_dimmer: {str(e)}")
        return 0  # Return a safe default value

def mfft_to_strobe(mfft_vec, mfft_range, threshold):
    try:
        mfft_low, mfft_high = int(mfft_range[0]), int(mfft_range[1])
        if mfft_low < 0 or mfft_high > len(mfft_vec):
            raise ValueError(f"MFFT range {mfft_range} is out of bounds for MFFT vector of length {len(mfft_vec)}")
        mfft_mean = np.mean(mfft_vec[mfft_low:mfft_high])
        return [255, 255] if mfft_mean >= threshold else [0, 0]
    except Exception as e:
        print(f"Error in mfft_to_strobe: {str(e)}")
        return [0, 0]  # Return a safe default value

def bool_dimmer(brightness):
    brightness = np.random.randint(0, 256) if brightness == 'random' else brightness
    return [int(brightness)]

def bool_rgb(brightness, color, strobe, colorfade):
    # expects color to be DMX value
    brightness = np.random.randint(0, 256) if brightness == 'random' else brightness
    return [int(brightness), int(color[0]), int(color[1]), int(color[2]), int(strobe), int(colorfade)]

def bool_strobe(speed, brightness):
    speed = np.random.randint(0, 256) if speed == 'random' else speed
    brightness = np.random.randint(0, 256) if brightness == 'random' else brightness
    return [int(speed), int(brightness)]

def time_function(t, frequency, function):
    if function == 0:  # sine
        return np.sin(t * frequency * 2 * np.pi) * 0.5 + 0.5
    elif function == 1:  # square
        return np.sign(np.sin(t * frequency * 2 * np.pi)) * 0.5 + 0.5
    elif function == 2:  # triangle
        return np.abs(((t * frequency) % 2) - 1)
    elif function == 3:  # sawtooth_forward
        return (t * frequency) % 1
    elif function == 4:  # sawtooth_backward
        return 1 - (t * frequency % 1)

def time_dimmer(t, min_brightness, max_brightness, frequency, function):
    range_brightness = max_brightness - min_brightness
    try:
        return int(min_brightness + range_brightness * time_function(t, frequency, function))
    except Exception as e:
        print(f"Error in time_dimmer0: {str(e)}")
        print(f"t: {t}, min_brightness: {min_brightness}, max_brightness: {max_brightness}, frequency: {frequency}, function: {function}")

def time_rgb(t, min_brightness, max_brightness, frequency, function, color, strobe):
    brightness = time_dimmer(t, min_brightness, max_brightness, frequency, function)
    return [int(brightness), int(color[0]), int(color[1]), int(color[2]), int(strobe), 0]

def time_strobe(t, speed_range, brightness_range, frequency, function, target):
    if target == 0:  # speed
        speed = time_function(t, frequency, function) * (speed_range[1] - speed_range[0]) + speed_range[0]
        return [int(speed), int(brightness_range[1])]

    elif target == 1:  # brightness
        brightness = time_function(t, frequency, function) * (brightness_range[1] - brightness_range[0]) + brightness_range[0]
        return [int(speed_range[1]), int(brightness)]

    else:  # default to both if target is invalid
        speed = time_function(t, frequency, function) * (speed_range[1] - speed_range[0]) + speed_range[0]
        brightness = time_function(t, frequency, function) * (brightness_range[1] - brightness_range[0]) + brightness_range[0]
        return [int(speed), int(brightness)]

# # Non-JIT functions that interface with the JIT functions
# def process_mfft_to_rgb(mfft_vec, light):
#     return mfft_to_rgb(mfft_vec, 
#                        light['mfft_range'], 
#                        light['power_range'], 
#                        light['brightness_range'], 
#                        light.get('color', 'random'), 
#                        light.get('strobe', 0))

def process_bool_dimmer(light): 
    return bool_dimmer(light['brightness'])

def process_bool_strobe(light):
    return bool_strobe(light['speed'], light['brightness'])

def process_bool_rgb(light):
    if 'colorfade' in light:
        colorfade = light['colorfade']
        color = [255,255,255]
        brightness = light['brightness']
        return bool_rgb(brightness, color, 0, colorfade)
    else:
        brightness = np.random.randint(0, 256) if light['brightness'] == 'random' else light['brightness']
        color = random_color() if light['color'] == 'random' else color_to_rgb(light['color'])
        strobe = np.random.randint(0, 256) if light.get('strobe') == 'random' else light.get('strobe', 0)
        return bool_rgb(brightness, color, strobe, 0)

def process_time_dimmer(light, t):
    function_index = ['sine', 'square', 'triangle', 'sawtooth_forward', 'sawtooth_backward'].index(light['function'])
    return time_dimmer(t, light['min_brightness'], light['max_brightness'], light['frequency'], function_index)

def process_time_rgb(light, t):
    color = random_color() if light['color'] == 'random' else color_to_rgb(light['color'])
    strobe = np.random.randint(0, 256) if light.get('strobe') == 'random' else light.get('strobe', 0)
    function_index = ['sine', 'square', 'triangle', 'sawtooth_forward', 'sawtooth_backward'].index(light['function'])
    return time_rgb(t, light['min_brightness'], light['max_brightness'], 
                    light['frequency'], function_index, color, strobe)

def process_time_strobe(light, t):
    function_index = ['sine', 'square', 'triangle', 'sawtooth_forward', 'sawtooth_backward'].index(light['function'])
    target_index = ['speed', 'brightness', 'both'].index(light['target'])
    return time_strobe(t, light['speed_range'], light['brightness_range'], 
                       light['frequency'], function_index, target_index)

# Main processing function
def process_light(light, mfft_vec, current_time):
    modulator = light['modulator']
    light_type = light['type']

    #print(f"Processing light: {light['name']}, modulator: {modulator}, type: {light_type}")
    #print(f"MFFT vector shape: {mfft_vec.shape}")

    if modulator == 'mfft':
        if light_type == 'dimmer':
            #print(f"MFFT range: {light['mfft_range']}")
            return [mfft_to_dimmer(mfft_vec, light['mfft_range'], light['power_range'], light['brightness_range'])]

        elif light_type == 'rgb':
            #print(f"MFFT range: {light['mfft_range']}")
            return mfft_to_rgb(mfft_vec, light['mfft_range'], light['power_range'], light['brightness_range'], light.get('color', 'random'), light.get('strobe', 0))

        elif light_type == 'strobe':
            #print(f"MFFT range: {light['mfft_range']}")
            return mfft_to_strobe(mfft_vec, light['mfft_range'], light['threshold'])

    elif modulator == 'bool':
        if light_type == 'dimmer':
            return process_bool_dimmer(light)

        elif light_type == 'rgb':
            return process_bool_rgb(light)

        elif light_type == 'strobe':
            return process_bool_strobe(light)
            
    elif modulator == 'time':
        if light_type == 'dimmer':
            try:
                return [time_dimmer(current_time, light['min_brightness'], light['max_brightness'], 
                                    light['frequency'], light['function'])]
            except Exception as e:
                print(f"Error in time_dimmer: {str(e)}")
                return [0]
                                
        elif light_type == 'rgb':
            return process_time_rgb(light, current_time)

        elif light_type == 'strobe':
            return process_time_strobe(light, current_time)

    return None  # Return None if no valid combination is found


def main():
    # random 128 length mfft vector
    mfft_data = np.random.rand(128)

    # random light profile
    light = {
        'modulator': 'mfft',
        'type': 'rgb',
        'mfft_range': (0, 128),
        'power_range': (0, 1),
        'brightness_range': (0, 255),
        'color': 'random',
        'strobe': 0
    }

    # process the light
    dmx_values = process_light(light, mfft_data, time.time())
    print(dmx_values)

if __name__ == "__main__":
    main()




            ----------------------------------------
